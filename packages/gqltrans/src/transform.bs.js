// Generated by BUCKLESCRIPT VERSION 4.0.7, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Utils = require("./utils.bs.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var $$String = require("bs-platform/lib/js/string.js");
var Gql_ast = require("./gql_ast.bs.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function m_string_value(tv) {
  if (tv.tag) {
    return /* BlockStringValue */Block.__(1, [tv[0]]);
  } else {
    return /* StringValue */Block.__(0, [tv[0]]);
  }
}

function tv_to_svc(v) {
  if (typeof v === "number") {
    return /* NullValue */0;
  } else {
    switch (v.tag | 0) {
      case 0 : 
          return /* IntValue */Block.__(0, [v[0]]);
      case 1 : 
          return /* FloatValue */Block.__(1, [v[0]]);
      case 2 : 
          return /* StringValue */Block.__(2, [m_string_value(v[0])]);
      case 3 : 
          return /* BooleanValue */Block.__(3, [v[0]]);
      case 4 : 
          return /* EnumValue */Block.__(4, [v[0]]);
      case 5 : 
          return /* ListValue */Block.__(5, [List.map(tv_to_svc, v[0])]);
      case 6 : 
          return /* ObjectValue */Block.__(6, [List.map(tof_to_sof, v[0])]);
      
    }
  }
}

function tof_to_sof(f) {
  return /* record */[
          /* name */f[/* name */0],
          /* value */tv_to_svc(f[/* value */1])
        ];
}

function starts_with(sub, prefix) {
  if (sub.length < prefix.length) {
    return false;
  } else {
    return $$String.sub(sub, 0, prefix.length) === prefix;
  }
}

var Transformation_error = Caml_exceptions.create("Transform.Schema.Transformation_error");

function listify(f, a, param) {
  var match = Curry._1(f, /* tuple */[
        a,
        param[1]
      ]);
  return /* tuple */[
          /* :: */[
            match[0],
            param[0]
          ],
          match[1]
        ];
}

function s_name(c, param) {
  var r = param[1];
  var n = param[0];
  var match = Curry._1(c[/* find_type_alias */0], n);
  if (match !== undefined) {
    return /* tuple */[
            match,
            r
          ];
  } else {
    return /* tuple */[
            n,
            r
          ];
  }
}

function s_tpe(c, param) {
  var r = param[1];
  var t = param[0];
  switch (t.tag | 0) {
    case 0 : 
        var match = s_name(c, /* tuple */[
              t[0],
              r
            ]);
        return /* tuple */[
                /* NamedType */Block.__(0, [match[0]]),
                match[1]
              ];
    case 1 : 
        var match$1 = s_tpe(c, /* tuple */[
              t[0],
              r
            ]);
        return /* tuple */[
                /* ListType */Block.__(1, [match$1[0]]),
                match$1[1]
              ];
    case 2 : 
        var match$2 = s_nnt(c, /* tuple */[
              t[0],
              r
            ]);
        return /* tuple */[
                /* NonNullType */Block.__(2, [match$2[0]]),
                match$2[1]
              ];
    
  }
}

function s_nnt(c, param) {
  var r = param[1];
  var t = param[0];
  if (t.tag) {
    var match = s_name(c, /* tuple */[
          t[0],
          r
        ]);
    return /* tuple */[
            /* NamedType */Block.__(1, [match[0]]),
            match[1]
          ];
  } else {
    var match$1 = s_tpe(c, /* tuple */[
          t[0],
          r
        ]);
    return /* tuple */[
            /* ListType */Block.__(0, [match$1[0]]),
            match$1[1]
          ];
  }
}

function s_operation_type_definition(c, param) {
  var d = param[0];
  var match = s_name(c, /* tuple */[
        d[/* tpe */1],
        param[1]
      ]);
  return /* tuple */[
          /* record */[
            /* operation */d[/* operation */0],
            /* tpe */match[0]
          ],
          match[1]
        ];
}

function s_schema_definition(c, param) {
  var r = param[1];
  var s = param[0];
  var match = c[/* schema_transformation */2];
  if (match !== undefined) {
    var ops = List.map((function (o) {
            return /* tuple */[
                    o[/* operation */0],
                    o
                  ];
          }), s[/* operations */1]);
    var match$1 = List.fold_right((function (t, param) {
            var match = Utils.assoc_opt(t, ops);
            if (match !== undefined) {
              var match$1 = s_operation_type_definition(c, /* tuple */[
                    match,
                    param[1]
                  ]);
              return /* tuple */[
                      /* :: */[
                        match$1[0],
                        param[0]
                      ],
                      match$1[1]
                    ];
            } else {
              throw [
                    Transformation_error,
                    "Operation not found"
                  ];
            }
          }), match, /* tuple */[
          /* [] */0,
          r
        ]);
    return /* tuple */[
            /* record */[
              /* directives */s[/* directives */0],
              /* operations */match$1[0]
            ],
            match$1[1]
          ];
  } else {
    var match$2 = List.fold_right((function (param, param$1) {
            return listify((function (param) {
                          return s_operation_type_definition(c, param);
                        }), param, param$1);
          }), s[/* operations */1], /* tuple */[
          /* [] */0,
          r
        ]);
    return /* tuple */[
            /* record */[
              /* directives */s[/* directives */0],
              /* operations */match$2[0]
            ],
            match$2[1]
          ];
  }
}

function s_input_value_definition(c, t, param) {
  var d = param[0];
  var match = t[/* description */0];
  var desced = match !== undefined ? /* record */[
      /* description */m_string_value(match),
      /* name */d[/* name */1],
      /* tpe */d[/* tpe */2],
      /* defaultValue */d[/* defaultValue */3],
      /* directives */d[/* directives */4]
    ] : d;
  var match$1 = s_tpe(c, /* tuple */[
        desced[/* tpe */2],
        param[1]
      ]);
  return /* tuple */[
          /* record */[
            /* description */desced[/* description */0],
            /* name */desced[/* name */1],
            /* tpe */match$1[0],
            /* defaultValue */desced[/* defaultValue */3],
            /* directives */desced[/* directives */4]
          ],
          match$1[1]
        ];
}

function s_input_values_definition(c, upd1, upd2, ts, param) {
  var args = List.map((function (v) {
          return /* tuple */[
                  v[/* name */1],
                  v
                ];
        }), ts);
  return List.fold_right((function (d, param) {
                var r = param[1];
                var ds = param[0];
                var match = Utils.assoc_opt(d[/* name */1], args);
                if (match !== undefined) {
                  var t = match;
                  var match$1 = t[/* value */2];
                  if (match$1 !== undefined) {
                    return /* tuple */[
                            ds,
                            Curry._2(upd1, /* record */[
                                  /* name */t[/* name */1],
                                  /* value */tv_to_svc(match$1)
                                ], r)
                          ];
                  } else {
                    var match$2 = s_input_value_definition(c, t, /* tuple */[
                          d,
                          r
                        ]);
                    var d$1 = match$2[0];
                    return /* tuple */[
                            /* :: */[
                              d$1,
                              ds
                            ],
                            Curry._2(upd2, d$1, match$2[1])
                          ];
                  }
                } else {
                  var match$3 = s_tpe(c, /* tuple */[
                        d[/* tpe */2],
                        r
                      ]);
                  return /* tuple */[
                          /* :: */[
                            /* record */[
                              /* description */d[/* description */0],
                              /* name */d[/* name */1],
                              /* tpe */match$3[0],
                              /* defaultValue */d[/* defaultValue */3],
                              /* directives */d[/* directives */4]
                            ],
                            ds
                          ],
                          Curry._2(upd2, d, match$3[1])
                        ];
                }
              }), param[0], /* tuple */[
              /* [] */0,
              param[1]
            ]);
}

function fd_arg_updater(tn, fn, arg, r) {
  return /* record */[
          /* types */r[/* types */0],
          /* fields */r[/* fields */1],
          /* input_fields */r[/* input_fields */2],
          /* arguments */r[/* arguments */3],
          /* directive_arguments */r[/* directive_arguments */4],
          /* new_fields */r[/* new_fields */5],
          /* fixed_arguments : :: */[
            /* tuple */[
              /* tuple */[
                tn,
                fn
              ],
              arg
            ],
            r[/* fixed_arguments */6]
          ],
          /* fixed_input_fields */r[/* fixed_input_fields */7]
        ];
}

function s_field_definition(c, tn, ft, param) {
  var fd = param[0];
  var match = ft[/* selector */1];
  var match$1 = match[/* alias */1];
  var named = match$1 !== undefined ? /* record */[
      /* description */fd[/* description */0],
      /* name */match$1,
      /* arguments */fd[/* arguments */2],
      /* tpe */fd[/* tpe */3],
      /* directives */fd[/* directives */4]
    ] : /* record */[
      /* description */fd[/* description */0],
      /* name */match[/* name */0],
      /* arguments */fd[/* arguments */2],
      /* tpe */fd[/* tpe */3],
      /* directives */fd[/* directives */4]
    ];
  var match$2 = ft[/* description */0];
  var described = match$2 !== undefined ? /* record */[
      /* description */m_string_value(match$2),
      /* name */named[/* name */1],
      /* arguments */named[/* arguments */2],
      /* tpe */named[/* tpe */3],
      /* directives */named[/* directives */4]
    ] : named;
  var partial_arg = described[/* name */1];
  var match$3 = s_input_values_definition(c, (function (param, param$1) {
          return fd_arg_updater(tn, partial_arg, param, param$1);
        }), (function (a, res) {
          return /* record */[
                  /* types */res[/* types */0],
                  /* fields */res[/* fields */1],
                  /* input_fields */res[/* input_fields */2],
                  /* arguments : :: */[
                    /* tuple */[
                      /* tuple */[
                        tn,
                        described[/* name */1],
                        a[/* name */1]
                      ],
                      a
                    ],
                    res[/* arguments */3]
                  ],
                  /* directive_arguments */res[/* directive_arguments */4],
                  /* new_fields */res[/* new_fields */5],
                  /* fixed_arguments */res[/* fixed_arguments */6],
                  /* fixed_input_fields */res[/* fixed_input_fields */7]
                ];
        }), ft[/* arguments */2], /* tuple */[
        named[/* arguments */2],
        param[1]
      ]);
  var match$4 = s_tpe(c, /* tuple */[
        described[/* tpe */3],
        match$3[1]
      ]);
  var r = match$4[1];
  var fd2_000 = /* description */described[/* description */0];
  var fd2_001 = /* name */described[/* name */1];
  var fd2_002 = /* arguments */match$3[0];
  var fd2_003 = /* tpe */match$4[0];
  var fd2_004 = /* directives */described[/* directives */4];
  var fd2 = /* record */[
    fd2_000,
    fd2_001,
    fd2_002,
    fd2_003,
    fd2_004
  ];
  return /* tuple */[
          fd2,
          /* record */[
            /* types */r[/* types */0],
            /* fields : :: */[
              /* tuple */[
                /* tuple */[
                  tn,
                  fd2_001
                ],
                fd
              ],
              r[/* fields */1]
            ],
            /* input_fields */r[/* input_fields */2],
            /* arguments */r[/* arguments */3],
            /* directive_arguments */r[/* directive_arguments */4],
            /* new_fields : :: */[
              /* tuple */[
                /* tuple */[
                  tn,
                  fd2_001
                ],
                fd2
              ],
              r[/* new_fields */5]
            ],
            /* fixed_arguments */r[/* fixed_arguments */6],
            /* fixed_input_fields */r[/* fixed_input_fields */7]
          ]
        ];
}

function s_fields_definition(c, tn, fts, param) {
  var r = param[1];
  var fds = param[0];
  if (fts) {
    var c$1 = c;
    var tn$1 = tn;
    var fts$1 = fts;
    var param$1 = /* tuple */[
      fds,
      r
    ];
    var fieldsAssoc = List.map((function (def) {
            return /* tuple */[
                    def[/* name */1],
                    def
                  ];
          }), param$1[0]);
    return List.fold_right((function (ft, param) {
                  var match = Utils.assoc_opt(ft[/* selector */1][/* name */0], fieldsAssoc);
                  if (match !== undefined) {
                    var match$1 = s_field_definition(c$1, tn$1, ft, /* tuple */[
                          match,
                          param[1]
                        ]);
                    return /* tuple */[
                            /* :: */[
                              match$1[0],
                              param[0]
                            ],
                            match$1[1]
                          ];
                  } else {
                    throw [
                          Transformation_error,
                          "Field with name: " + (ft[/* selector */1][/* name */0] + " not found.")
                        ];
                  }
                }), fts$1, /* tuple */[
                /* [] */0,
                param$1[1]
              ]);
  } else {
    return List.fold_right((function (param, param$1) {
                  return listify((function (param) {
                                var c$2 = c;
                                var tn$2 = tn;
                                var param$1 = param;
                                var f = param$1[0];
                                var partial_arg = f[/* name */1];
                                var match = s_input_values_definition(c$2, (function (param, param$1) {
                                        return fd_arg_updater(tn$2, partial_arg, param, param$1);
                                      }), (function (a, res) {
                                        return /* record */[
                                                /* types */res[/* types */0],
                                                /* fields */res[/* fields */1],
                                                /* input_fields */res[/* input_fields */2],
                                                /* arguments : :: */[
                                                  /* tuple */[
                                                    /* tuple */[
                                                      tn$2,
                                                      f[/* name */1],
                                                      a[/* name */1]
                                                    ],
                                                    a
                                                  ],
                                                  res[/* arguments */3]
                                                ],
                                                /* directive_arguments */res[/* directive_arguments */4],
                                                /* new_fields */res[/* new_fields */5],
                                                /* fixed_arguments */res[/* fixed_arguments */6],
                                                /* fixed_input_fields */res[/* fixed_input_fields */7]
                                              ];
                                      }), /* [] */0, /* tuple */[
                                      f[/* arguments */2],
                                      param$1[1]
                                    ]);
                                var match$1 = s_tpe(c$2, /* tuple */[
                                      f[/* tpe */3],
                                      match[1]
                                    ]);
                                var r = match$1[1];
                                var fd2_000 = /* description */f[/* description */0];
                                var fd2_001 = /* name */f[/* name */1];
                                var fd2_002 = /* arguments */match[0];
                                var fd2_003 = /* tpe */match$1[0];
                                var fd2_004 = /* directives */f[/* directives */4];
                                var fd2 = /* record */[
                                  fd2_000,
                                  fd2_001,
                                  fd2_002,
                                  fd2_003,
                                  fd2_004
                                ];
                                return /* tuple */[
                                        fd2,
                                        /* record */[
                                          /* types */r[/* types */0],
                                          /* fields : :: */[
                                            /* tuple */[
                                              /* tuple */[
                                                tn$2,
                                                f[/* name */1]
                                              ],
                                              f
                                            ],
                                            r[/* fields */1]
                                          ],
                                          /* input_fields */r[/* input_fields */2],
                                          /* arguments */r[/* arguments */3],
                                          /* directive_arguments */r[/* directive_arguments */4],
                                          /* new_fields : :: */[
                                            /* tuple */[
                                              /* tuple */[
                                                tn$2,
                                                fd2_001
                                              ],
                                              fd2
                                            ],
                                            r[/* new_fields */5]
                                          ],
                                          /* fixed_arguments */r[/* fixed_arguments */6],
                                          /* fixed_input_fields */r[/* fixed_input_fields */7]
                                        ]
                                      ];
                              }), param, param$1);
                }), fds, /* tuple */[
                /* [] */0,
                r
              ]);
  }
}

function s_object_type_definition(c, param) {
  var d = param[0];
  var t = Curry._1(c[/* find_object_type_transformation */3], d[/* name */1]);
  var desced;
  if (t !== undefined) {
    var match = t[/* description */0];
    desced = match !== undefined ? /* record */[
        /* description */m_string_value(match),
        /* name */d[/* name */1],
        /* implements */d[/* implements */2],
        /* directives */d[/* directives */3],
        /* fields */d[/* fields */4]
      ] : d;
  } else {
    desced = d;
  }
  var fts = t !== undefined ? t[/* fields */2] : /* [] */0;
  var match$1 = s_name(c, /* tuple */[
        desced[/* name */1],
        param[1]
      ]);
  var n = match$1[0];
  var match$2 = List.fold_right((function (param, param$1) {
          return listify((function (param) {
                        return s_name(c, param);
                      }), param, param$1);
        }), desced[/* implements */2], /* tuple */[
        /* [] */0,
        match$1[1]
      ]);
  var match$3 = s_fields_definition(c, n, fts, /* tuple */[
        d[/* fields */4],
        match$2[1]
      ]);
  return /* tuple */[
          /* record */[
            /* description */desced[/* description */0],
            /* name */n,
            /* implements */match$2[0],
            /* directives */desced[/* directives */3],
            /* fields */match$3[0]
          ],
          match$3[1]
        ];
}

function s_interface_type_definition(c, param) {
  var d = param[0];
  var t = Curry._1(c[/* find_interface_type_transformation */4], d[/* name */1]);
  var fields = t !== undefined ? t[/* fields */2] : /* [] */0;
  var desced;
  if (t !== undefined) {
    var match = t[/* description */0];
    desced = match !== undefined ? /* record */[
        /* description */m_string_value(match),
        /* name */d[/* name */1],
        /* directives */d[/* directives */2],
        /* fields */d[/* fields */3]
      ] : d;
  } else {
    desced = d;
  }
  var match$1 = s_name(c, /* tuple */[
        desced[/* name */1],
        param[1]
      ]);
  var n = match$1[0];
  var match$2 = s_fields_definition(c, n, fields, /* tuple */[
        d[/* fields */3],
        match$1[1]
      ]);
  return /* tuple */[
          /* record */[
            /* description */desced[/* description */0],
            /* name */n,
            /* directives */desced[/* directives */2],
            /* fields */match$2[0]
          ],
          match$2[1]
        ];
}

function s_scalar_type_definition(c, param) {
  var p1 = param[0];
  var t = Curry._1(c[/* find_scalar_type_transformation */5], p1[/* name */1]);
  var desced;
  if (t !== undefined) {
    var match = t[/* description */0];
    desced = match !== undefined ? /* record */[
        /* description */m_string_value(match),
        /* name */p1[/* name */1],
        /* directives */p1[/* directives */2]
      ] : p1;
  } else {
    desced = p1;
  }
  var match$1 = s_name(c, /* tuple */[
        p1[/* name */1],
        param[1]
      ]);
  return /* tuple */[
          /* record */[
            /* description */desced[/* description */0],
            /* name */match$1[0],
            /* directives */desced[/* directives */2]
          ],
          match$1[1]
        ];
}

function s_union_type_definition(c, param) {
  var p1 = param[0];
  var p2 = Curry._1(c[/* find_union_type_transformation */7], p1[/* name */1]);
  var described;
  if (p2 !== undefined) {
    var match = p2[/* description */0];
    described = match !== undefined ? /* record */[
        /* description */m_string_value(match),
        /* name */p1[/* name */1],
        /* directives */p1[/* directives */2],
        /* types */p1[/* types */3]
      ] : p1;
  } else {
    described = p1;
  }
  var match$1 = s_name(c, /* tuple */[
        p1[/* name */1],
        param[1]
      ]);
  var match$2 = List.fold_right((function (param, param$1) {
          return listify((function (param) {
                        return s_name(c, param);
                      }), param, param$1);
        }), p1[/* types */3], /* tuple */[
        /* [] */0,
        match$1[1]
      ]);
  return /* tuple */[
          /* record */[
            /* description */described[/* description */0],
            /* name */match$1[0],
            /* directives */described[/* directives */2],
            /* types */match$2[0]
          ],
          match$2[1]
        ];
}

function s_enum_value_definition(param, t, param$1) {
  var r = param$1[1];
  var d = param$1[0];
  var match = t[/* description */0];
  if (match !== undefined) {
    return /* tuple */[
            /* record */[
              /* description */m_string_value(match),
              /* value */d[/* value */1],
              /* directives */d[/* directives */2]
            ],
            r
          ];
  } else {
    return /* tuple */[
            d,
            r
          ];
  }
}

function s_enum_values_definition(c, ds, param) {
  var trans = List.map((function (d) {
          return /* tuple */[
                  d[/* value */1],
                  d
                ];
        }), param[0]);
  return List.fold_right((function (d, param) {
                var r = param[1];
                var ds = param[0];
                var match = Utils.assoc_opt(d[/* value */1], trans);
                if (match !== undefined) {
                  var match$1 = s_enum_value_definition(c, match, /* tuple */[
                        d,
                        r
                      ]);
                  return /* tuple */[
                          /* :: */[
                            match$1[0],
                            ds
                          ],
                          match$1[1]
                        ];
                } else {
                  return /* tuple */[
                          /* :: */[
                            d,
                            ds
                          ],
                          r
                        ];
                }
              }), ds, /* tuple */[
              /* [] */0,
              param[1]
            ]);
}

function s_enum_type_definition(c, param) {
  var d = param[0];
  var t = Curry._1(c[/* find_enum_type_transformation */6], d[/* name */1]);
  var described;
  if (t !== undefined) {
    var match = t[/* description */0];
    described = match !== undefined ? /* record */[
        /* description */m_string_value(match),
        /* name */d[/* name */1],
        /* directives */d[/* directives */2],
        /* values */d[/* values */3]
      ] : d;
  } else {
    described = d;
  }
  var values = t !== undefined ? t[/* values */2] : /* [] */0;
  var match$1 = s_name(c, /* tuple */[
        d[/* name */1],
        param[1]
      ]);
  var match$2 = s_enum_values_definition(c, d[/* values */3], /* tuple */[
        values,
        match$1[1]
      ]);
  return /* tuple */[
          /* record */[
            /* description */described[/* description */0],
            /* name */match$1[0],
            /* directives */described[/* directives */2],
            /* values */match$2[0]
          ],
          match$2[1]
        ];
}

function s_input_object_type_definition(c, param) {
  var d = param[0];
  var t = Curry._1(c[/* find_input_object_type_transformation */8], d[/* name */1]);
  var described;
  if (t !== undefined) {
    var match = t[/* description */0];
    described = match !== undefined ? /* record */[
        /* description */m_string_value(match),
        /* name */d[/* name */1],
        /* directives */d[/* directives */2],
        /* fields */d[/* fields */3]
      ] : d;
  } else {
    described = d;
  }
  var fields = t !== undefined ? t[/* fields */2] : /* [] */0;
  var match$1 = s_name(c, /* tuple */[
        d[/* name */1],
        param[1]
      ]);
  var n = match$1[0];
  var match$2 = s_input_values_definition(c, (function (param, param$1) {
          var tn = n;
          var c = param;
          var r = param$1;
          return /* record */[
                  /* types */r[/* types */0],
                  /* fields */r[/* fields */1],
                  /* input_fields */r[/* input_fields */2],
                  /* arguments */r[/* arguments */3],
                  /* directive_arguments */r[/* directive_arguments */4],
                  /* new_fields */r[/* new_fields */5],
                  /* fixed_arguments */r[/* fixed_arguments */6],
                  /* fixed_input_fields : :: */[
                    /* tuple */[
                      tn,
                      c
                    ],
                    r[/* fixed_input_fields */7]
                  ]
                ];
        }), (function (a, r) {
          return /* record */[
                  /* types */r[/* types */0],
                  /* fields */r[/* fields */1],
                  /* input_fields : :: */[
                    /* tuple */[
                      /* tuple */[
                        n,
                        a[/* name */1]
                      ],
                      a
                    ],
                    r[/* input_fields */2]
                  ],
                  /* arguments */r[/* arguments */3],
                  /* directive_arguments */r[/* directive_arguments */4],
                  /* new_fields */r[/* new_fields */5],
                  /* fixed_arguments */r[/* fixed_arguments */6],
                  /* fixed_input_fields */r[/* fixed_input_fields */7]
                ];
        }), fields, /* tuple */[
        d[/* fields */3],
        match$1[1]
      ]);
  return /* tuple */[
          /* record */[
            /* description */described[/* description */0],
            /* name */n,
            /* directives */described[/* directives */2],
            /* fields */match$2[0]
          ],
          match$2[1]
        ];
}

function find_generator(m, l, n) {
  var match = Utils.assoc_opt(n, l);
  if (match !== undefined) {
    return Js_primitive.some(Curry._1(m, Js_primitive.valFromOption(match)));
  }
  
}

function s(s$1, t) {
  var match = List.fold_right((function (c, param) {
          var ts = param[1];
          if (c.tag) {
            return /* tuple */[
                    c[0],
                    ts
                  ];
          } else {
            var t = c[0];
            return /* tuple */[
                    param[0],
                    /* :: */[
                      /* tuple */[
                        t[0][/* selector */1][/* name */0],
                        t
                      ],
                      ts
                    ]
                  ];
          }
        }), t[/* transformations */0], /* tuple */[
        undefined,
        /* [] */0
      ]);
  var types = match[1];
  var err = [
    Transformation_error,
    "Transformation type mismatch"
  ];
  var ctx_000 = function (n) {
    var match = Utils.assoc_opt(n, types);
    if (match !== undefined) {
      return match[0][/* selector */1][/* alias */1];
    }
    
  };
  var ctx_001 = function (n) {
    return Utils.assoc_opt(n, types);
  };
  var ctx_002 = /* schema_transformation */match[0];
  var ctx_003 = function (param) {
    return find_generator((function (v) {
                  if (v.tag === 1) {
                    return v[0];
                  } else {
                    throw err;
                  }
                }), types, param);
  };
  var ctx_004 = function (param) {
    return find_generator((function (v) {
                  if (v.tag === 2) {
                    return v[0];
                  } else {
                    throw err;
                  }
                }), types, param);
  };
  var ctx_005 = function (param) {
    return find_generator((function (v) {
                  if (v.tag) {
                    throw err;
                  } else {
                    return v[0];
                  }
                }), types, param);
  };
  var ctx_006 = function (param) {
    return find_generator((function (v) {
                  if (v.tag === 4) {
                    return v[0];
                  } else {
                    throw err;
                  }
                }), types, param);
  };
  var ctx_007 = function (param) {
    return find_generator((function (v) {
                  if (v.tag === 3) {
                    return v[0];
                  } else {
                    throw err;
                  }
                }), types, param);
  };
  var ctx_008 = function (param) {
    return find_generator((function (v) {
                  if (v.tag === 5) {
                    return v[0];
                  } else {
                    throw err;
                  }
                }), types, param);
  };
  var ctx = /* record */[
    ctx_000,
    ctx_001,
    ctx_002,
    ctx_003,
    ctx_004,
    ctx_005,
    ctx_006,
    ctx_007,
    ctx_008
  ];
  var c = ctx;
  var param = /* tuple */[
    s$1,
    /* record */[
      /* types : [] */0,
      /* fields : [] */0,
      /* input_fields : [] */0,
      /* arguments : [] */0,
      /* directive_arguments : [] */0,
      /* new_fields : [] */0,
      /* fixed_arguments : [] */0,
      /* fixed_input_fields : [] */0
    ]
  ];
  var d = param[0];
  var match$1 = s_schema_definition(c, /* tuple */[
        d[/* schema */0],
        param[1]
      ]);
  var match$2 = List.fold_right((function (param, param$1) {
          return listify((function (param) {
                        var c$1 = c;
                        var param$1 = param;
                        var r = param$1[1];
                        var d = param$1[0];
                        switch (d.tag | 0) {
                          case 0 : 
                              var match = s_scalar_type_definition(c$1, /* tuple */[
                                    d[0],
                                    r
                                  ]);
                              var res = match[1];
                              var s = match[0];
                              return /* tuple */[
                                      /* ScalarTypeDefinition */Block.__(0, [s]),
                                      /* record */[
                                        /* types : :: */[
                                          /* tuple */[
                                            s[/* name */1],
                                            d
                                          ],
                                          res[/* types */0]
                                        ],
                                        /* fields */res[/* fields */1],
                                        /* input_fields */res[/* input_fields */2],
                                        /* arguments */res[/* arguments */3],
                                        /* directive_arguments */res[/* directive_arguments */4],
                                        /* new_fields */res[/* new_fields */5],
                                        /* fixed_arguments */res[/* fixed_arguments */6],
                                        /* fixed_input_fields */res[/* fixed_input_fields */7]
                                      ]
                                    ];
                          case 1 : 
                              var match$1 = s_object_type_definition(c$1, /* tuple */[
                                    d[0],
                                    r
                                  ]);
                              var res$1 = match$1[1];
                              var s$1 = match$1[0];
                              return /* tuple */[
                                      /* ObjectTypeDefinition */Block.__(1, [s$1]),
                                      /* record */[
                                        /* types : :: */[
                                          /* tuple */[
                                            s$1[/* name */1],
                                            d
                                          ],
                                          res$1[/* types */0]
                                        ],
                                        /* fields */res$1[/* fields */1],
                                        /* input_fields */res$1[/* input_fields */2],
                                        /* arguments */res$1[/* arguments */3],
                                        /* directive_arguments */res$1[/* directive_arguments */4],
                                        /* new_fields */res$1[/* new_fields */5],
                                        /* fixed_arguments */res$1[/* fixed_arguments */6],
                                        /* fixed_input_fields */res$1[/* fixed_input_fields */7]
                                      ]
                                    ];
                          case 2 : 
                              var match$2 = s_interface_type_definition(c$1, /* tuple */[
                                    d[0],
                                    r
                                  ]);
                              var res$2 = match$2[1];
                              var s$2 = match$2[0];
                              return /* tuple */[
                                      /* InterfaceTypeDefinition */Block.__(2, [s$2]),
                                      /* record */[
                                        /* types : :: */[
                                          /* tuple */[
                                            s$2[/* name */1],
                                            d
                                          ],
                                          res$2[/* types */0]
                                        ],
                                        /* fields */res$2[/* fields */1],
                                        /* input_fields */res$2[/* input_fields */2],
                                        /* arguments */res$2[/* arguments */3],
                                        /* directive_arguments */res$2[/* directive_arguments */4],
                                        /* new_fields */res$2[/* new_fields */5],
                                        /* fixed_arguments */res$2[/* fixed_arguments */6],
                                        /* fixed_input_fields */res$2[/* fixed_input_fields */7]
                                      ]
                                    ];
                          case 3 : 
                              var match$3 = s_union_type_definition(c$1, /* tuple */[
                                    d[0],
                                    r
                                  ]);
                              var res$3 = match$3[1];
                              var s$3 = match$3[0];
                              return /* tuple */[
                                      /* UnionTypeDefinition */Block.__(3, [s$3]),
                                      /* record */[
                                        /* types : :: */[
                                          /* tuple */[
                                            s$3[/* name */1],
                                            d
                                          ],
                                          res$3[/* types */0]
                                        ],
                                        /* fields */res$3[/* fields */1],
                                        /* input_fields */res$3[/* input_fields */2],
                                        /* arguments */res$3[/* arguments */3],
                                        /* directive_arguments */res$3[/* directive_arguments */4],
                                        /* new_fields */res$3[/* new_fields */5],
                                        /* fixed_arguments */res$3[/* fixed_arguments */6],
                                        /* fixed_input_fields */res$3[/* fixed_input_fields */7]
                                      ]
                                    ];
                          case 4 : 
                              var match$4 = s_enum_type_definition(c$1, /* tuple */[
                                    d[0],
                                    r
                                  ]);
                              var res$4 = match$4[1];
                              var s$4 = match$4[0];
                              return /* tuple */[
                                      /* EnumTypeDefinition */Block.__(4, [s$4]),
                                      /* record */[
                                        /* types : :: */[
                                          /* tuple */[
                                            s$4[/* name */1],
                                            d
                                          ],
                                          res$4[/* types */0]
                                        ],
                                        /* fields */res$4[/* fields */1],
                                        /* input_fields */res$4[/* input_fields */2],
                                        /* arguments */res$4[/* arguments */3],
                                        /* directive_arguments */res$4[/* directive_arguments */4],
                                        /* new_fields */res$4[/* new_fields */5],
                                        /* fixed_arguments */res$4[/* fixed_arguments */6],
                                        /* fixed_input_fields */res$4[/* fixed_input_fields */7]
                                      ]
                                    ];
                          case 5 : 
                              var match$5 = s_input_object_type_definition(c$1, /* tuple */[
                                    d[0],
                                    r
                                  ]);
                              var res$5 = match$5[1];
                              var s$5 = match$5[0];
                              return /* tuple */[
                                      /* InputObjectTypeDefinition */Block.__(5, [s$5]),
                                      /* record */[
                                        /* types : :: */[
                                          /* tuple */[
                                            s$5[/* name */1],
                                            d
                                          ],
                                          res$5[/* types */0]
                                        ],
                                        /* fields */res$5[/* fields */1],
                                        /* input_fields */res$5[/* input_fields */2],
                                        /* arguments */res$5[/* arguments */3],
                                        /* directive_arguments */res$5[/* directive_arguments */4],
                                        /* new_fields */res$5[/* new_fields */5],
                                        /* fixed_arguments */res$5[/* fixed_arguments */6],
                                        /* fixed_input_fields */res$5[/* fixed_input_fields */7]
                                      ]
                                    ];
                          
                        }
                      }), param, param$1);
        }), d[/* types */2], /* tuple */[
        /* [] */0,
        match$1[1]
      ]);
  var match$3 = List.fold_right((function (param, param$1) {
          return listify((function (param) {
                        var c$1 = c;
                        var param$1 = param;
                        var d = param$1[0];
                        var match = s_input_values_definition(c$1, (function (param) {
                                return Utils.identity;
                              }), (function (a, res) {
                                return /* record */[
                                        /* types */res[/* types */0],
                                        /* fields */res[/* fields */1],
                                        /* input_fields */res[/* input_fields */2],
                                        /* arguments */res[/* arguments */3],
                                        /* directive_arguments : :: */[
                                          /* tuple */[
                                            /* tuple */[
                                              d[/* name */1],
                                              a[/* name */1]
                                            ],
                                            a
                                          ],
                                          res[/* directive_arguments */4]
                                        ],
                                        /* new_fields */res[/* new_fields */5],
                                        /* fixed_arguments */res[/* fixed_arguments */6],
                                        /* fixed_input_fields */res[/* fixed_input_fields */7]
                                      ];
                              }), /* [] */0, /* tuple */[
                              d[/* arguments */2],
                              param$1[1]
                            ]);
                        return /* tuple */[
                                /* record */[
                                  /* description */d[/* description */0],
                                  /* name */d[/* name */1],
                                  /* arguments */match[0],
                                  /* locations */d[/* locations */3]
                                ],
                                match[1]
                              ];
                      }), param, param$1);
        }), d[/* directives */1], /* tuple */[
        /* [] */0,
        match$2[1]
      ]);
  return /* tuple */[
          /* record */[
            /* schema */match$1[0],
            /* directives */match$3[0],
            /* types */match$2[0]
          ],
          match$3[1]
        ];
}

var Correction_error = Caml_exceptions.create("Transform.Correct.Correction_error");

function c_directive(m, c, d) {
  var partial_arg = d[/* name */0];
  var partial_arg$1 = function (param) {
    var s1 = partial_arg;
    var s2 = param;
    var match = Utils.assoc_opt(/* tuple */[
          s1,
          s2
        ], c[/* dirArgs */1]);
    if (match !== undefined) {
      return Curry._1(m, match);
    } else {
      throw [
            Correction_error,
            "Failed to find directive with name " + (s1 + (" and argument " + s2))
          ];
    }
  };
  return /* record */[
          /* name */d[/* name */0],
          /* arguments */List.map((function (param) {
                  var m = partial_arg$1;
                  var a = param;
                  return /* record */[
                          /* name */a[/* name */0],
                          /* value */Curry._2(m, a[/* name */0], a[/* value */1])
                        ];
                }), d[/* arguments */1])
        ];
}

function c_object_fields_const(c, n, v) {
  var vs = List.fold_right((function (v, acc) {
          return /* :: */[
                  /* tuple */[
                    v[/* name */0],
                    v
                  ],
                  acc
                ];
        }), v, /* [] */0);
  return List.fold_right((function (v, acc) {
                var match = Utils.assoc_opt(v[/* name */1], vs);
                if (match !== undefined) {
                  var f = match;
                  return /* :: */[
                          /* record */[
                            /* name */f[/* name */0],
                            /* value */c_value_const(c, v[/* tpe */2], f[/* value */1])
                          ],
                          acc
                        ];
                } else {
                  return acc;
                }
              }), n[/* fields */3], /* [] */0);
}

function c_value_const(c, _t, v) {
  while(true) {
    var t = _t;
    switch (t.tag | 0) {
      case 0 : 
          if (typeof v === "number" || v.tag !== 6) {
            return v;
          } else {
            var v$1 = v[0];
            var match = Utils.assoc_opt(t[0], c[/* inputs */0]);
            if (match !== undefined) {
              return /* ObjectValue */Block.__(6, [c_object_fields_const(c, match, v$1)]);
            } else {
              return /* ObjectValue */Block.__(6, [v$1]);
            }
          }
      case 1 : 
          var t$1 = t[0];
          if (typeof v === "number") {
            _t = t$1;
            continue ;
          } else if (v.tag === 5) {
            return /* ListValue */Block.__(5, [List.map((function(t$1){
                          return function (param) {
                            return c_value_const(c, t$1, param);
                          }
                          }(t$1)), v[0])]);
          } else {
            _t = t$1;
            continue ;
          }
      case 2 : 
          var match$1 = t[0];
          if (typeof v === "number") {
            return v;
          } else if (match$1.tag) {
            _t = /* NamedType */Block.__(0, [match$1[0]]);
            continue ;
          } else {
            _t = /* ListType */Block.__(1, [match$1[0]]);
            continue ;
          }
      
    }
  };
}

function c_input_value_definition(c, d) {
  var partial_arg = d[/* tpe */2];
  return /* record */[
          /* description */d[/* description */0],
          /* name */d[/* name */1],
          /* tpe */d[/* tpe */2],
          /* defaultValue */Utils.opt_map((function (param) {
                  return c_value_const(c, partial_arg, param);
                }), d[/* defaultValue */3]),
          /* directives */d[/* directives */4]
        ];
}

function c_field_definition(c, f) {
  return /* record */[
          /* description */f[/* description */0],
          /* name */f[/* name */1],
          /* arguments */List.map((function (param) {
                  return c_input_value_definition(c, param);
                }), f[/* arguments */2]),
          /* tpe */f[/* tpe */3],
          /* directives */List.map((function (param) {
                  return c_directive((function (param, param$1) {
                                return c_value_const(c, param, param$1);
                              }), c, param);
                }), f[/* directives */4])
        ];
}

function c_scalar_type_definition(c, t) {
  return /* record */[
          /* description */t[/* description */0],
          /* name */t[/* name */1],
          /* directives */List.map((function (param) {
                  return c_directive((function (param, param$1) {
                                return c_value_const(c, param, param$1);
                              }), c, param);
                }), t[/* directives */2])
        ];
}

function c_object_type_definition(c, t) {
  return /* record */[
          /* description */t[/* description */0],
          /* name */t[/* name */1],
          /* implements */t[/* implements */2],
          /* directives */List.map((function (param) {
                  return c_directive((function (param, param$1) {
                                return c_value_const(c, param, param$1);
                              }), c, param);
                }), t[/* directives */3]),
          /* fields */List.map((function (param) {
                  return c_field_definition(c, param);
                }), t[/* fields */4])
        ];
}

function c_interface_type_definition(c, t) {
  return /* record */[
          /* description */t[/* description */0],
          /* name */t[/* name */1],
          /* directives */List.map((function (param) {
                  return c_directive((function (param, param$1) {
                                return c_value_const(c, param, param$1);
                              }), c, param);
                }), t[/* directives */2]),
          /* fields */List.map((function (param) {
                  return c_field_definition(c, param);
                }), t[/* fields */3])
        ];
}

function c_union_type_definition(c, t) {
  return /* record */[
          /* description */t[/* description */0],
          /* name */t[/* name */1],
          /* directives */List.map((function (param) {
                  return c_directive((function (param, param$1) {
                                return c_value_const(c, param, param$1);
                              }), c, param);
                }), t[/* directives */2]),
          /* types */t[/* types */3]
        ];
}

function c_enum_type_definition(c, t) {
  return /* record */[
          /* description */t[/* description */0],
          /* name */t[/* name */1],
          /* directives */List.map((function (param) {
                  return c_directive((function (param, param$1) {
                                return c_value_const(c, param, param$1);
                              }), c, param);
                }), t[/* directives */2]),
          /* values */List.map((function (param) {
                  var c$1 = c;
                  var d = param;
                  return /* record */[
                          /* description */d[/* description */0],
                          /* value */d[/* value */1],
                          /* directives */List.map((function (param) {
                                  return c_directive((function (param, param$1) {
                                                return c_value_const(c$1, param, param$1);
                                              }), c$1, param);
                                }), d[/* directives */2])
                        ];
                }), t[/* values */3])
        ];
}

function c_input_object_type_definition(c, t) {
  return /* record */[
          /* description */t[/* description */0],
          /* name */t[/* name */1],
          /* directives */List.map((function (param) {
                  return c_directive((function (param, param$1) {
                                return c_value_const(c, param, param$1);
                              }), c, param);
                }), t[/* directives */2]),
          /* fields */List.map((function (param) {
                  return c_input_value_definition(c, param);
                }), t[/* fields */3])
        ];
}

function c(s) {
  var inputs = List.fold_right((function (t, acc) {
          if (t.tag === 5) {
            var t$1 = t[0];
            return /* :: */[
                    /* tuple */[
                      t$1[/* name */1],
                      t$1
                    ],
                    acc
                  ];
          } else {
            return acc;
          }
        }), s[/* types */2], /* [] */0);
  var dirArgs = List.fold_right((function (d, acc) {
          return List.fold_right((function (a, acc) {
                        return /* :: */[
                                /* tuple */[
                                  /* tuple */[
                                    d[/* name */1],
                                    a[/* name */1]
                                  ],
                                  a[/* tpe */2]
                                ],
                                acc
                              ];
                      }), d[/* arguments */2], acc);
        }), s[/* directives */1], /* [] */0);
  var c$1 = /* record */[
    /* inputs */inputs,
    /* dirArgs */dirArgs
  ];
  var d = s;
  var dirs = List.map((function (param) {
          var c$2 = c$1;
          var d = param;
          return /* record */[
                  /* description */d[/* description */0],
                  /* name */d[/* name */1],
                  /* arguments */List.map((function (param) {
                          return c_input_value_definition(c$2, param);
                        }), d[/* arguments */2]),
                  /* locations */d[/* locations */3]
                ];
        }), d[/* directives */1]);
  var tps = List.map((function (param) {
          var c$2 = c$1;
          var d = param;
          switch (d.tag | 0) {
            case 0 : 
                return /* ScalarTypeDefinition */Block.__(0, [c_scalar_type_definition(c$2, d[0])]);
            case 1 : 
                return /* ObjectTypeDefinition */Block.__(1, [c_object_type_definition(c$2, d[0])]);
            case 2 : 
                return /* InterfaceTypeDefinition */Block.__(2, [c_interface_type_definition(c$2, d[0])]);
            case 3 : 
                return /* UnionTypeDefinition */Block.__(3, [c_union_type_definition(c$2, d[0])]);
            case 4 : 
                return /* EnumTypeDefinition */Block.__(4, [c_enum_type_definition(c$2, d[0])]);
            case 5 : 
                return /* InputObjectTypeDefinition */Block.__(5, [c_input_object_type_definition(c$2, d[0])]);
            
          }
        }), d[/* types */2]);
  return /* record */[
          /* schema */d[/* schema */0],
          /* directives */dirs,
          /* types */tps
        ];
}

function d_field_definition(c, td, l) {
  return List.fold_right((function (param) {
                var partial_arg = param[/* tpe */2];
                return (function (param) {
                    return d_tpe(c, partial_arg, param);
                  });
              }), td[/* arguments */2], d_tpe(c, td[/* tpe */3], l));
}

function d_name(c, n, l) {
  if (List.exists((function (v) {
            return v === n;
          }), l)) {
    return l;
  } else {
    var match = Utils.assoc_opt(n, c[/* types */0]);
    if (match !== undefined) {
      var c$1 = c;
      var t = match;
      var l$1 = l;
      switch (t.tag | 0) {
        case 1 : 
            var tt = t[0];
            return List.fold_right((function (param, param$1) {
                          return d_field_definition(c$1, param, param$1);
                        }), tt[/* fields */4], List.fold_right((function (param, param$1) {
                              return d_name(c$1, param, param$1);
                            }), tt[/* implements */2], /* :: */[
                            tt[/* name */1],
                            l$1
                          ]));
        case 2 : 
            var tt$1 = t[0];
            return List.fold_right((function (param, param$1) {
                          return d_field_definition(c$1, param, param$1);
                        }), tt$1[/* fields */3], d_possible_types(c$1, tt$1[/* name */1])(/* :: */[
                            tt$1[/* name */1],
                            l$1
                          ]));
        case 3 : 
            var tt$2 = t[0];
            return List.fold_right((function (e, acc) {
                          return /* :: */[
                                  e,
                                  acc
                                ];
                        }), tt$2[/* types */3], /* :: */[
                        tt$2[/* name */1],
                        l$1
                      ]);
        case 0 : 
        case 4 : 
            return /* :: */[
                    t[0][/* name */1],
                    l$1
                  ];
        case 5 : 
            var tt$3 = t[0];
            return List.fold_right((function (param) {
                          var partial_arg = param[/* tpe */2];
                          return (function (param) {
                              return d_tpe(c$1, partial_arg, param);
                            });
                        }), tt$3[/* fields */3], /* :: */[
                        tt$3[/* name */1],
                        l$1
                      ]);
        
      }
    } else {
      return l;
    }
  }
}

function d_tpe(c, _tt, l) {
  while(true) {
    var tt = _tt;
    switch (tt.tag | 0) {
      case 0 : 
          return d_name(c, tt[0], l);
      case 1 : 
          _tt = tt[0];
          continue ;
      case 2 : 
          var match = tt[0];
          if (match.tag) {
            _tt = /* NamedType */Block.__(0, [match[0]]);
            continue ;
          } else {
            _tt = match[0];
            continue ;
          }
      
    }
  };
}

function d_possible_types(c, n) {
  var partial_arg = Utils.assoc_filter(n, c[/* possibleTypes */1]);
  return (function (param) {
      return List.fold_right((function (param, param$1) {
                    return d_name(c, param, param$1);
                  }), partial_arg, param);
    });
}

function c$1(d) {
  var c$2 = List.fold_right((function (t, acc) {
          if (t.tag === 1) {
            var tt = t[0];
            return /* record */[
                    /* types : :: */[
                      /* tuple */[
                        tt[/* name */1],
                        t
                      ],
                      acc[/* types */0]
                    ],
                    /* possibleTypes */List.fold_right((function (v, acc) {
                            return /* :: */[
                                    /* tuple */[
                                      v,
                                      tt[/* name */1]
                                    ],
                                    acc
                                  ];
                          }), tt[/* implements */2], acc[/* possibleTypes */1])
                  ];
          } else {
            return /* record */[
                    /* types : :: */[
                      /* tuple */[
                        t[0][/* name */1],
                        t
                      ],
                      acc[/* types */0]
                    ],
                    /* possibleTypes */acc[/* possibleTypes */1]
                  ];
          }
        }), d[/* types */2], /* record */[
        /* types : [] */0,
        /* possibleTypes : [] */0
      ]);
  var tps = List.fold_right((function (param) {
          var c$3 = c$2;
          var t = param;
          var partial_arg = t[/* arguments */2];
          return (function (param) {
              return List.fold_right((function (param) {
                            var partial_arg = param[/* tpe */2];
                            return (function (param) {
                                return d_tpe(c$3, partial_arg, param);
                              });
                          }), partial_arg, param);
            });
        }), d[/* directives */1], List.fold_right((function (param) {
              var partial_arg = param[/* tpe */1];
              return (function (param) {
                  return d_name(c$2, partial_arg, param);
                });
            }), d[/* schema */0][/* operations */1], /* [] */0));
  return /* record */[
          /* schema */d[/* schema */0],
          /* directives */d[/* directives */1],
          /* types */List.filter((function (v) {
                    return List.exists((function (e) {
                                  return e === v[0][/* name */1];
                                }), tps);
                  }))(d[/* types */2])
        ];
}

var TypeError = Caml_exceptions.create("Transform.TypeCheck.TypeError");

function tt_object_type_defnition_1(param, s) {
  var match = s[/* fields */4];
  if (match) {
    return /* () */0;
  } else {
    throw [
          TypeError,
          "An object type must define one or more fields"
        ];
  }
}

function unique(f, e, l) {
  List.fold_right((function (a, acc) {
          if (List.exists(Curry._1(f, a), acc)) {
            throw e;
          } else {
            return /* :: */[
                    a,
                    acc
                  ];
          }
        }), l, /* [] */0);
  return /* () */0;
}

function is_output_type(c, _t) {
  while(true) {
    var t = _t;
    switch (t.tag | 0) {
      case 0 : 
          var match = Curry._1(c[/* find_type */3], t[0]);
          if (match.tag === 5) {
            return false;
          } else {
            return true;
          }
      case 1 : 
          _t = t[0];
          continue ;
      case 2 : 
          var match$1 = t[0];
          if (match$1.tag) {
            _t = /* NamedType */Block.__(0, [match$1[0]]);
            continue ;
          } else {
            _t = match$1[0];
            continue ;
          }
      
    }
  };
}

function is_input_type(c, _t) {
  while(true) {
    var t = _t;
    switch (t.tag | 0) {
      case 0 : 
          var match = Curry._1(c[/* find_type */3], t[0]);
          switch (match.tag | 0) {
            case 0 : 
            case 4 : 
            case 5 : 
                return true;
            default:
              return false;
          }
      case 1 : 
          _t = t[0];
          continue ;
      case 2 : 
          var match$1 = t[0];
          if (match$1.tag) {
            _t = /* NamedType */Block.__(0, [match$1[0]]);
            continue ;
          } else {
            _t = match$1[0];
            continue ;
          }
      
    }
  };
}

function forall(condition, e, l) {
  if (List.for_all(condition, l)) {
    return /* () */0;
  } else {
    throw e;
  }
}

function tt_object_type_defnition_2_1(param, s) {
  var err = [
    TypeError,
    "The field must have a unique name within that Object type; no two fields may share the same name."
  ];
  return unique((function (f1, f2) {
                return f1[/* name */1] === f2[/* name */1];
              }), err, s[/* fields */4]);
}

function tt_object_type_defnition_2_2(param, s) {
  var err = [
    TypeError,
    "The field must not have a name which begins with the characters \"__\" (two underscores)."
  ];
  return forall((function (f) {
                return !starts_with(f[/* name */1], "__");
              }), err, s[/* fields */4]);
}

function tt_object_type_defnition_2_3(c, s) {
  var err = [
    TypeError,
    "The field must return a type where IsOutputType(fieldType) returns true."
  ];
  return forall((function (f) {
                return is_output_type(c, f[/* tpe */3]);
              }), err, s[/* fields */4]);
}

function tt_object_type_defnition_2_4_1(param, s) {
  var err = [
    TypeError,
    "The argument must not have a name which begins with the characters \"__\" (two underscores)."
  ];
  return forall((function (f) {
                return !starts_with(f[/* name */1], "__");
              }), err, s[/* arguments */2]);
}

function tt_object_type_defnition_2(c, s) {
  try {
    tt_object_type_defnition_2_1(c, s);
    tt_object_type_defnition_2_2(c, s);
    tt_object_type_defnition_2_3(c, s);
    var c$1 = c;
    var s$1 = s;
    try {
      return List.fold_right((function (f, param) {
                    tt_object_type_defnition_2_4_1(c$1, f);
                    var c$2 = c$1;
                    var s = f;
                    var err = [
                      TypeError,
                      "The argument must accept a type where IsInputType(argumentType) returns true."
                    ];
                    return forall((function (f) {
                                  return is_input_type(c$2, f[/* tpe */2]);
                                }), err, s[/* arguments */2]);
                  }), s$1[/* fields */4], /* () */0);
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === TypeError) {
        throw [
              TypeError,
              "For each argument of the field: " + exn[1]
            ];
      } else {
        throw exn;
      }
    }
  }
  catch (raw_exn$1){
    var exn$1 = Js_exn.internalToOCamlException(raw_exn$1);
    if (exn$1[0] === TypeError) {
      throw [
            TypeError,
            "For each field of an Object type: " + exn$1[1]
          ];
    } else {
      throw exn$1;
    }
  }
}

function tt_object_type_definition_3(c, s) {
  var err = [
    TypeError,
    "An object type may declare that it implements one or more unique interfaces."
  ];
  var is = List.map((function (n) {
          var match = Utils.assoc_opt(n, c[/* interfaces */0]);
          if (match !== undefined) {
            return match;
          } else {
            throw err;
          }
        }), s[/* implements */2]);
  return unique((function (prim, prim$1) {
                return prim === prim$1;
              }), err, is);
}

function is_equal(c, _t1, _t2) {
  while(true) {
    var t2 = _t2;
    var t1 = _t1;
    switch (t1.tag | 0) {
      case 0 : 
          switch (t2.tag | 0) {
            case 0 : 
                return Curry._1(c[/* find_type */3], t1[0]) === Curry._1(c[/* find_type */3], t2[0]);
            case 1 : 
            case 2 : 
                return false;
            
          }
      case 1 : 
          switch (t2.tag | 0) {
            case 1 : 
                _t2 = t2[0];
                _t1 = t1[0];
                continue ;
            case 0 : 
            case 2 : 
                return false;
            
          }
      case 2 : 
          var match = t1[0];
          if (match.tag) {
            switch (t2.tag | 0) {
              case 0 : 
              case 1 : 
                  return false;
              case 2 : 
                  var match$1 = t2[0];
                  if (match$1.tag) {
                    _t2 = /* NamedType */Block.__(0, [match$1[0]]);
                    _t1 = /* NamedType */Block.__(0, [match[0]]);
                    continue ;
                  } else {
                    return false;
                  }
              
            }
          } else {
            return false;
          }
      
    }
  };
}

function is_sub_type_or_equal(c, _sub, _sup) {
  while(true) {
    var sup = _sup;
    var sub = _sub;
    switch (sub.tag | 0) {
      case 0 : 
          switch (sup.tag | 0) {
            case 0 : 
                var t1 = Curry._1(c[/* find_type */3], sub[0]);
                var t2 = Curry._1(c[/* find_type */3], sup[0]);
                if (t1 === t2) {
                  return true;
                } else if (t1.tag === 1) {
                  switch (t2.tag | 0) {
                    case 2 : 
                        return List.exists((function(t1){
                                  return function (t2) {
                                    return t1 === t2;
                                  }
                                  }(t1)), List.map((function (n) {
                                          return Curry._1(c[/* find_type */3], n);
                                        }), t1[0][/* implements */2]));
                    case 3 : 
                        return List.exists((function(t1){
                                  return function (t2) {
                                    return t1 === t2;
                                  }
                                  }(t1)), List.map((function (n) {
                                          return Curry._1(c[/* find_type */3], n);
                                        }), t2[0][/* types */3]));
                    default:
                      return false;
                  }
                } else {
                  return false;
                }
            case 1 : 
            case 2 : 
                return false;
            
          }
      case 1 : 
          switch (sup.tag | 0) {
            case 1 : 
                _sup = sup[0];
                _sub = sub[0];
                continue ;
            case 0 : 
            case 2 : 
                return false;
            
          }
      case 2 : 
          var match = sub[0];
          if (match.tag) {
            var t1$1 = match[0];
            switch (sup.tag | 0) {
              case 0 : 
                  _sup = /* NamedType */Block.__(0, [sup[0]]);
                  _sub = /* NamedType */Block.__(0, [t1$1]);
                  continue ;
              case 1 : 
                  return false;
              case 2 : 
                  var match$1 = sup[0];
                  if (match$1.tag) {
                    _sup = /* NamedType */Block.__(0, [match$1[0]]);
                    _sub = /* NamedType */Block.__(0, [t1$1]);
                    continue ;
                  } else {
                    return false;
                  }
              
            }
          } else {
            switch (sup.tag | 0) {
              case 0 : 
              case 1 : 
                  return false;
              case 2 : 
                  var match$2 = sup[0];
                  if (match$2.tag) {
                    return false;
                  } else {
                    _sup = match$2[0];
                    _sub = match[0];
                    continue ;
                  }
              
            }
          }
      
    }
  };
}

function tt_object_type_defnition_4_1_1(c, i, f) {
  var err = [
    TypeError,
    "The object field must be of a type which is equal to or a sub\xe2\x80\x90type of the interface field (covariant)."
  ];
  if (is_sub_type_or_equal(c, f[/* tpe */3], i[/* tpe */3])) {
    return /* () */0;
  } else {
    throw err;
  }
}

function tt_object_type_defnition_4_1_2(c, i, f) {
  var err = [
    TypeError,
    "The object field must include an argument of the same name for every argument defined in the interface field."
  ];
  var argAssoc = List.map((function (a) {
          return /* tuple */[
                  a[/* name */1],
                  a
                ];
        }), f[/* arguments */2]);
  return List.fold_right((function (ia, param) {
                var match = Utils.assoc_opt(ia[/* name */1], argAssoc);
                if (match !== undefined) {
                  var c$1 = c;
                  var i = ia;
                  var f = match;
                  if (is_equal(c$1, i[/* tpe */2], f[/* tpe */2])) {
                    return /* () */0;
                  } else {
                    throw [
                          TypeError,
                          "The object field argument must accept the same type (invariant) as the interface field argument."
                        ];
                  }
                } else {
                  throw err;
                }
              }), i[/* arguments */2], /* () */0);
}

function tt_object_type_defnition_4(c, s) {
  try {
    var c$1 = c;
    var s$1 = s;
    var err = "The object type must include a field of the same name for every field defined in an interface. ";
    var fieldAssoc = List.map((function (f) {
            return /* tuple */[
                    f[/* name */1],
                    f
                  ];
          }), s$1[/* fields */4]);
    try {
      return List.fold_right((function (iff, param) {
                    var match = Utils.assoc_opt(iff[/* name */1], fieldAssoc);
                    var f;
                    if (match !== undefined) {
                      f = match;
                    } else {
                      throw [
                            TypeError,
                            err
                          ];
                    }
                    tt_object_type_defnition_4_1_1(c$1, iff, f);
                    tt_object_type_defnition_4_1_2(c$1, iff, f);
                    var i = iff;
                    var f$1 = f;
                    var err$1 = [
                      TypeError,
                      "The object field may include additional arguments not defined in the interface field, but any additional argument must not be required, e.g. must not be of a non\xe2\x80\x90nullable type."
                    ];
                    var interfaceArgsAssoc = List.map((function (a) {
                            return /* tuple */[
                                    a[/* name */1],
                                    a
                                  ];
                          }), i[/* arguments */2]);
                    return List.fold_right((function (a, param) {
                                  var match = a[/* tpe */2];
                                  var match$1 = Utils.assoc_opt(a[/* name */1], interfaceArgsAssoc);
                                  switch (match.tag | 0) {
                                    case 0 : 
                                    case 1 : 
                                        return /* () */0;
                                    case 2 : 
                                        if (match$1 !== undefined) {
                                          return /* () */0;
                                        } else {
                                          throw err$1;
                                        }
                                    
                                  }
                                }), f$1[/* arguments */2], /* () */0);
                  }), List.flatten(List.map((function (i) {
                            return i[/* fields */3];
                          }), List.map((function (n) {
                                return Curry._1(c$1[/* find_interface */4], n);
                              }), s$1[/* implements */2]))), /* () */0);
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === TypeError) {
        throw [
              TypeError,
              err + exn[1]
            ];
      } else {
        throw exn;
      }
    }
  }
  catch (raw_exn$1){
    var exn$1 = Js_exn.internalToOCamlException(raw_exn$1);
    if (exn$1[0] === TypeError) {
      throw [
            TypeError,
            "An object type must be a super\xe2\x80\x90set of all interfaces it implements: " + exn$1[1]
          ];
    } else {
      throw exn$1;
    }
  }
}

function tt_interface_type_definition_1(param, s) {
  var match = s[/* fields */3];
  if (match) {
    return /* () */0;
  } else {
    throw [
          TypeError,
          "An Interface type must define one or more fields."
        ];
  }
}

function tt_interface_type_definition_2_1(param, s) {
  var err = [
    TypeError,
    "The field must have a unique name within that Interface type; no two fields may share the same name."
  ];
  return unique((function (f1, f2) {
                return f1[/* name */1] === f2[/* name */1];
              }), err, s[/* fields */3]);
}

function tt_interface_type_definition_2_2(param, s) {
  var err = [
    TypeError,
    "The field must not have a name which begins with the characters \"__\" (two underscores)."
  ];
  return forall((function (f) {
                return !starts_with(f[/* name */1], "__");
              }), err, s[/* fields */3]);
}

function tt_interface_type_definition_2_3(c, s) {
  var err = [
    TypeError,
    "The field must return a type where IsOutputType(fieldType) returns true."
  ];
  return forall((function (f) {
                return is_output_type(c, f[/* tpe */3]);
              }), err, s[/* fields */3]);
}

function tt_interface_type_definition_2_4_1(param, f) {
  var err = [
    TypeError,
    "The argument must not have a name which begins with the characters \"__\" (two underscores)."
  ];
  return forall((function (f) {
                return !starts_with(f[/* name */1], "__");
              }), err, f[/* arguments */2]);
}

function tt_union_type_definition_1(param, s) {
  var err = [
    TypeError,
    "A Union type must include one or more unique member types."
  ];
  var ss = s[/* types */3];
  if (ss) {
    return unique(Caml_obj.caml_equal, err, ss);
  } else {
    throw err;
  }
}

function tt_input_object_definition_1(param, s) {
  var err = [
    TypeError,
    "An Input Object type must define one or more input fields."
  ];
  var match = s[/* fields */3];
  if (match) {
    return /* () */0;
  } else {
    throw err;
  }
}

function tt_input_object_definition_2_1(param, s) {
  var err = [
    TypeError,
    "The input field must have a unique name within that Input Object type; no two input fields may share the same name."
  ];
  return unique((function (n1, n2) {
                return n1[/* name */1] === n2[/* name */1];
              }), err, s[/* fields */3]);
}

function tt_input_object_definition_2_2(param, s) {
  var err = [
    TypeError,
    "The input field must not have a name which begins with the characters \"__\" (two underscores)."
  ];
  return forall((function (f) {
                return !starts_with(f[/* name */1], "__");
              }), err, s[/* fields */3]);
}

function tt_directive_definition_1(c, d) {
  var dirs = List.map((function (d) {
          return Curry._1(c[/* find_directive */5], d[/* name */0]);
        }), List.flatten(List.map((function (d) {
                  return d[/* directives */4];
                }), d[/* arguments */2])));
  var err = [
    TypeError,
    "A directive definition must not contain the use of a directive which references itself directly."
  ];
  if (List.exists((function (a) {
            return a === d;
          }), dirs)) {
    throw err;
  } else {
    return /* () */0;
  }
}

function foreach(f, l) {
  return List.fold_right((function (a, param) {
                return Curry._1(f, a);
              }), l, /* () */0);
}

function c_directive$1(c, err, param, d) {
  var h1 = param[0];
  var dir = Curry._1(c[/* find_directive */5], d[/* name */0]);
  var exists = List.exists((function (d2) {
          return d2 === dir;
        }), h1);
  if (exists) {
    throw err;
  } else {
    return c_directive_definition(c, err, /* tuple */[
                h1,
                param[1]
              ], dir);
  }
}

function c_type_definition(c, err, param, t) {
  var history_000 = param[0];
  var history_001 = /* :: */[
    t,
    param[1]
  ];
  var history = /* tuple */[
    history_000,
    history_001
  ];
  switch (t.tag | 0) {
    case 0 : 
        return foreach((function (param) {
                      return c_directive$1(c, err, history, param);
                    }), t[0][/* directives */2]);
    case 1 : 
        var match = t[0];
        foreach((function (param) {
                return c_directive$1(c, err, history, param);
              }), match[/* directives */3]);
        foreach((function (param) {
                return c_field_definition$1(c, err, history, param);
              }), match[/* fields */4]);
        return foreach((function (param) {
                      return c_type_definition(c, err, history, param);
                    }), List.map(c[/* find_type */3], match[/* implements */2]));
    case 2 : 
        var match$1 = t[0];
        foreach((function (param) {
                return c_directive$1(c, err, history, param);
              }), match$1[/* directives */2]);
        return foreach((function (param) {
                      return c_field_definition$1(c, err, history, param);
                    }), match$1[/* fields */3]);
    case 3 : 
        var match$2 = t[0];
        foreach((function (param) {
                return c_directive$1(c, err, history, param);
              }), match$2[/* directives */2]);
        return foreach((function (param) {
                      return c_type_definition(c, err, history, param);
                    }), List.map(c[/* find_type */3], match$2[/* types */3]));
    case 4 : 
        var match$3 = t[0];
        foreach((function (param) {
                return c_directive$1(c, err, history, param);
              }), match$3[/* directives */2]);
        return foreach((function (param) {
                      var c$1 = c;
                      var err$1 = err;
                      var h = history;
                      var t = param;
                      return foreach((function (param) {
                                    return c_directive$1(c$1, err$1, h, param);
                                  }), t[/* directives */2]);
                    }), match$3[/* values */3]);
    case 5 : 
        var match$4 = t[0];
        foreach((function (param) {
                return c_directive$1(c, err, history, param);
              }), match$4[/* directives */2]);
        return foreach((function (param) {
                      return c_input_value_definition$1(c, err, history, param);
                    }), match$4[/* fields */3]);
    
  }
}

function c_input_value_definition$1(c, err, h, t) {
  foreach((function (param) {
          return c_directive$1(c, err, h, param);
        }), t[/* directives */4]);
  return c_tpe(c, err, h, t[/* tpe */2]);
}

function c_field_definition$1(c, err, h, d) {
  foreach((function (param) {
          return c_directive$1(c, err, h, param);
        }), d[/* directives */4]);
  foreach((function (param) {
          return c_input_value_definition$1(c, err, h, param);
        }), d[/* arguments */2]);
  return c_tpe(c, err, h, d[/* tpe */3]);
}

function c_tpe(c, err, history, _t) {
  while(true) {
    var t = _t;
    switch (t.tag | 0) {
      case 0 : 
          var c$1 = c;
          var err$1 = err;
          var param = history;
          var n = t[0];
          var h2 = param[1];
          var t$1 = Curry._1(c$1[/* find_type */3], n);
          var exists = List.exists((function(t$1){
              return function (t2) {
                return t$1 === t2;
              }
              }(t$1)), h2);
          if (exists) {
            return /* () */0;
          } else {
            return c_type_definition(c$1, err$1, /* tuple */[
                        param[0],
                        h2
                      ], t$1);
          }
      case 1 : 
          _t = t[0];
          continue ;
      case 2 : 
          var match = t[0];
          if (match.tag) {
            _t = /* NamedType */Block.__(0, [match[0]]);
            continue ;
          } else {
            _t = match[0];
            continue ;
          }
      
    }
  };
}

function c_directive_definition(c, err, param, d) {
  var partial_arg_000 = /* :: */[
    d,
    param[0]
  ];
  var partial_arg_001 = param[1];
  var partial_arg = /* tuple */[
    partial_arg_000,
    partial_arg_001
  ];
  return foreach((function (param) {
                return c_input_value_definition$1(c, err, partial_arg, param);
              }), d[/* arguments */2]);
}

function tt_directive_definition_2(c, d) {
  var err = [
    TypeError,
    "A directive definition must not contain the use of a directive which references itself indirectly by referencing a Type or Directive which transitively includes a reference to this directive."
  ];
  c_directive_definition(c, err, /* tuple */[
        /* [] */0,
        /* [] */0
      ], d);
  return /* () */0;
}

function tt_directive_definition_3(param, d) {
  var err = [
    TypeError,
    "The directive must not have a name which begins with the characters \"__\" (two underscores)."
  ];
  if (starts_with(d[/* name */1], "__")) {
    throw err;
  } else {
    return /* () */0;
  }
}

function tt_directive_definition_4_1(param, s) {
  var err = [
    TypeError,
    "The argument must not have a name which begins with the characters \"__\" (two underscores)."
  ];
  return forall((function (f) {
                return !starts_with(f[/* name */1], "__");
              }), err, s[/* arguments */2]);
}

function tt_schema(c, s) {
  List.fold_right((function (op, param) {
          var match = Curry._1(c[/* find_type */3], op[/* tpe */1]);
          if (match.tag === 1) {
            return /* () */0;
          } else {
            throw [
                  TypeError,
                  "Operations must be an object type"
                ];
          }
        }), s[/* operations */1], /* () */0);
  var match = Utils.find_opt((function (op) {
          return op[/* operation */0] === /* Query */0;
        }), s[/* operations */1]);
  if (match !== undefined) {
    return /* () */0;
  } else {
    throw [
          TypeError,
          "A query operation must be defined."
        ];
  }
}

function c$2(doc) {
  var interfaces = List.fold_right((function (l, acc) {
          if (l.tag === 2) {
            var d = l[0];
            return /* :: */[
                    /* tuple */[
                      d[/* name */1],
                      d
                    ],
                    acc
                  ];
          } else {
            return acc;
          }
        }), doc[/* types */2], /* [] */0);
  var types = List.map((function (t) {
          return /* tuple */[
                  t[0][/* name */1],
                  t
                ];
        }), List.append(doc[/* types */2], /* :: */[
            /* ScalarTypeDefinition */Block.__(0, [/* record */[
                  /* description */undefined,
                  /* name */"String",
                  /* directives : [] */0
                ]]),
            /* :: */[
              /* ScalarTypeDefinition */Block.__(0, [/* record */[
                    /* description */undefined,
                    /* name */"Int",
                    /* directives : [] */0
                  ]]),
              /* :: */[
                /* ScalarTypeDefinition */Block.__(0, [/* record */[
                      /* description */undefined,
                      /* name */"Float",
                      /* directives : [] */0
                    ]]),
                /* :: */[
                  /* ScalarTypeDefinition */Block.__(0, [/* record */[
                        /* description */undefined,
                        /* name */"Boolean",
                        /* directives : [] */0
                      ]]),
                  /* :: */[
                    /* ScalarTypeDefinition */Block.__(0, [/* record */[
                          /* description */undefined,
                          /* name */"ID",
                          /* directives : [] */0
                        ]]),
                    /* [] */0
                  ]
                ]
              ]
            ]
          ]));
  var directives = List.map((function (d) {
          return /* tuple */[
                  d[/* name */1],
                  d
                ];
        }), doc[/* directives */1]);
  var ctx_003 = function (param) {
    var c = types;
    var n = param;
    try {
      return List.assoc(n, c);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        throw [
              TypeError,
              "Failed to find type with name: " + n
            ];
      } else {
        throw exn;
      }
    }
  };
  var ctx_004 = function (param) {
    var c = interfaces;
    var n = param;
    try {
      return List.assoc(n, c);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        throw [
              TypeError,
              "Failed to find type with name: " + n
            ];
      } else {
        throw exn;
      }
    }
  };
  var ctx_005 = function (param) {
    var d = directives;
    var n = param;
    try {
      return List.assoc(n, d);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        throw [
              TypeError,
              "Failed to find directive with name: " + n
            ];
      } else {
        throw exn;
      }
    }
  };
  var ctx = /* record */[
    /* interfaces */interfaces,
    /* types */types,
    /* directives */directives,
    ctx_003,
    ctx_004,
    ctx_005
  ];
  List.fold_right((function (t, param) {
          var ctx$1 = ctx;
          var d = t;
          var err = [
            TypeError,
            "The type must not have a name which begins with the characters \"__\" (two underscores)."
          ];
          var c = function (n) {
            if (starts_with(n, "__")) {
              throw err;
            } else {
              return /* () */0;
            }
          };
          switch (d.tag | 0) {
            case 0 : 
                c(d[0][/* name */1]);
                return /* () */0;
            case 1 : 
                var t$1 = d[0];
                c(t$1[/* name */1]);
                var c$1 = ctx$1;
                var s = t$1;
                tt_object_type_defnition_1(c$1, s);
                tt_object_type_defnition_2(c$1, s);
                tt_object_type_definition_3(c$1, s);
                tt_object_type_defnition_4(c$1, s);
                return /* () */0;
            case 2 : 
                var t$2 = d[0];
                c(t$2[/* name */1]);
                var c$2 = ctx$1;
                var s$1 = t$2;
                tt_interface_type_definition_1(c$2, s$1);
                var c$3 = c$2;
                var s$2 = s$1;
                try {
                  tt_interface_type_definition_2_1(c$3, s$2);
                  tt_interface_type_definition_2_2(c$3, s$2);
                  tt_interface_type_definition_2_3(c$3, s$2);
                  var c$4 = c$3;
                  var s$3 = s$2;
                  try {
                    return List.fold_right((function (field, param) {
                                  tt_interface_type_definition_2_4_1(c$4, field);
                                  var c$5 = c$4;
                                  var f = field;
                                  var err = [
                                    TypeError,
                                    "The argument must accept a type where IsInputType(argumentType) returns true."
                                  ];
                                  return forall((function (f) {
                                                return is_input_type(c$5, f[/* tpe */2]);
                                              }), err, f[/* arguments */2]);
                                }), s$3[/* fields */3], /* () */0);
                  }
                  catch (raw_exn){
                    var exn = Js_exn.internalToOCamlException(raw_exn);
                    if (exn[0] === TypeError) {
                      throw [
                            TypeError,
                            "For each argument of the field:" + exn[1]
                          ];
                    } else {
                      throw exn;
                    }
                  }
                }
                catch (raw_exn$1){
                  var exn$1 = Js_exn.internalToOCamlException(raw_exn$1);
                  if (exn$1[0] === TypeError) {
                    throw [
                          TypeError,
                          "For each field of an Interface type:" + exn$1[1]
                        ];
                  } else {
                    throw exn$1;
                  }
                }
            case 3 : 
                var t$3 = d[0];
                c(t$3[/* name */1]);
                var c$5 = ctx$1;
                var s$4 = t$3;
                tt_union_type_definition_1(c$5, s$4);
                var c$6 = c$5;
                var s$5 = s$4;
                var err$1 = [
                  TypeError,
                  "The member types of a Union type must all be Object base types; Scalar, Interface and Union types must not be member types of a Union. Similarly, wrapping types must not be member types of a Union."
                ];
                return List.fold_right((function (t, param) {
                              var match = Curry._1(c$6[/* find_type */3], t);
                              if (match.tag === 1) {
                                return /* () */0;
                              } else {
                                throw err$1;
                              }
                            }), s$5[/* types */3], /* () */0);
            case 4 : 
                var t$4 = d[0];
                c(t$4[/* name */1]);
                var s$6 = t$4;
                var err$2 = [
                  TypeError,
                  "An Enum type must define one or more unique enum values."
                ];
                var ss = s$6[/* values */3];
                if (ss) {
                  return unique(Caml_obj.caml_equal, err$2, ss);
                } else {
                  throw err$2;
                }
            case 5 : 
                var t$5 = d[0];
                c(t$5[/* name */1]);
                var c$7 = ctx$1;
                var s$7 = t$5;
                tt_input_object_definition_1(c$7, s$7);
                var c$8 = c$7;
                var s$8 = s$7;
                try {
                  tt_input_object_definition_2_1(c$8, s$8);
                  tt_input_object_definition_2_2(c$8, s$8);
                  var c$9 = c$8;
                  var s$9 = s$8;
                  var err$3 = [
                    TypeError,
                    "The input field must accept a type where IsInputType(inputFieldType) returns true."
                  ];
                  return forall((function (f) {
                                return is_input_type(c$9, f[/* tpe */2]);
                              }), err$3, s$9[/* fields */3]);
                }
                catch (raw_exn$2){
                  var exn$2 = Js_exn.internalToOCamlException(raw_exn$2);
                  if (exn$2[0] === TypeError) {
                    throw [
                          TypeError,
                          "For each input field of an Input Object type:" + exn$2[1]
                        ];
                  } else {
                    throw exn$2;
                  }
                }
            
          }
        }), doc[/* types */2], /* () */0);
  tt_schema(ctx, doc[/* schema */0]);
  List.fold_right((function (t, param) {
          var c = ctx;
          var d = t;
          tt_directive_definition_1(c, d);
          tt_directive_definition_2(c, d);
          tt_directive_definition_3(c, d);
          var c$1 = c;
          var d$1 = d;
          try {
            tt_directive_definition_4_1(c$1, d$1);
            var c$2 = c$1;
            var s = d$1;
            var err = [
              TypeError,
              "The argument must accept a type where IsInputType(argumentType) returns true."
            ];
            return forall((function (f) {
                          return is_input_type(c$2, f[/* tpe */2]);
                        }), err, s[/* arguments */2]);
          }
          catch (raw_exn){
            var exn = Js_exn.internalToOCamlException(raw_exn);
            if (exn[0] === TypeError) {
              throw [
                    TypeError,
                    "For each argument of the directive:" + exn[1]
                  ];
            } else {
              throw exn;
            }
          }
        }), doc[/* directives */1], /* () */0);
  return doc;
}

function schema(t) {
  return t[/* ts */3];
}

function transform(s$1, t) {
  var match = s(s$1, t);
  return /* record */[
          /* t */t,
          /* os */s$1,
          /* tr */match[1],
          /* ts */c$2(c$1(c(match[0])))
        ];
}

var Transformation_error$1 = Caml_exceptions.create("Transform.Exec.Transformation_error");

function t_value(c, _t, v) {
  while(true) {
    var t = _t;
    switch (t.tag | 0) {
      case 0 : 
          if (typeof v === "number" || v.tag !== 7) {
            return v;
          } else {
            var match = Curry._1(c[/* find_type */1], t[0]);
            if (match.tag === 5) {
              return /* ObjectValue */Block.__(7, [t_object_fields(c, match[0], v[0])]);
            } else {
              return v;
            }
          }
      case 1 : 
          var t$1 = t[0];
          if (typeof v === "number") {
            _t = t$1;
            continue ;
          } else if (v.tag === 6) {
            return /* ListValue */Block.__(6, [List.map((function(t$1){
                          return function (param) {
                            return t_value(c, t$1, param);
                          }
                          }(t$1)), v[0])]);
          } else {
            _t = t$1;
            continue ;
          }
      case 2 : 
          var match$1 = t[0];
          if (match$1.tag) {
            _t = /* NamedType */Block.__(0, [match$1[0]]);
            continue ;
          } else {
            _t = /* ListType */Block.__(1, [match$1[0]]);
            continue ;
          }
      
    }
  };
}

function t_object_fields(c, o, fs) {
  return List.concat(/* :: */[
              List.map((function (param) {
                      var c$1 = c;
                      var l = function (n) {
                        return Curry._2(c[/* find_input_field */4], o[/* name */1], n);
                      };
                      var f = param;
                      var d = Curry._1(l, f[/* name */0]);
                      var v = t_value(c$1, d[/* tpe */2], f[/* value */1]);
                      return /* record */[
                              /* name */f[/* name */0],
                              /* value */v
                            ];
                    }), fs),
              /* :: */[
                List.map((function (a) {
                        return Gql_ast.a_to_of(Gql_ast.map_a(a, Gql_ast.vc_to_v));
                      }), Curry._1(c[/* find_fixed_field */8], o[/* name */1])),
                /* [] */0
              ]
            ]);
}

function t_argument(c, l, a) {
  var d = Curry._1(l, a[/* name */0]);
  return /* record */[
          /* name */a[/* name */0],
          /* value */t_value(c, d[/* tpe */2], a[/* value */1])
        ];
}

function t_directive(c, d) {
  var partial_arg = Curry._1(c[/* find_directive_argument */3], d[/* name */0]);
  return /* record */[
          /* name */d[/* name */0],
          /* arguments */List.map((function (param) {
                  return t_argument(c, partial_arg, param);
                }), d[/* arguments */1])
        ];
}

function t_fragment_spread(c, f) {
  return /* record */[
          /* name */f[/* name */0],
          /* directives */List.map((function (param) {
                  return t_directive(c, param);
                }), f[/* directives */1])
        ];
}

function tpe_to_name(_t) {
  while(true) {
    var t = _t;
    switch (t.tag | 0) {
      case 0 : 
          return t[0];
      case 1 : 
          _t = t[0];
          continue ;
      case 2 : 
          var match = t[0];
          if (match.tag) {
            return match[0];
          } else {
            _t = /* ListType */Block.__(1, [match[0]]);
            continue ;
          }
      
    }
  };
}

function t_field(c, t, f) {
  var fd = Curry._2(c[/* find_field */2], t, f[/* name */1]);
  var nfd = Curry._2(c[/* find_new_field */6], t, f[/* name */1]);
  var name = f[/* name */1];
  var alias = f[/* alias */0];
  var name$1 = fd[/* name */1];
  var alias$1 = alias !== undefined ? alias : name;
  var alias$2 = name$1 === alias$1 ? undefined : alias$1;
  var partial_arg = Curry._2(c[/* find_field_argument */5], t, f[/* name */1]);
  var orig_args = List.map((function (param) {
          return t_argument(c, partial_arg, param);
        }), f[/* arguments */2]);
  var args = Curry._2(c[/* find_fixed_arguments */7], t, f[/* name */1]);
  var args$1 = List.map((function (a) {
          return /* record */[
                  /* name */a[/* name */0],
                  /* value */Gql_ast.vc_to_v(a[/* value */1])
                ];
        }), args);
  var directives = List.map((function (param) {
          return t_directive(c, param);
        }), f[/* directives */3]);
  return /* record */[
          /* alias */alias$2,
          /* name */fd[/* name */1],
          /* arguments */List.concat(/* :: */[
                orig_args,
                /* :: */[
                  args$1,
                  /* [] */0
                ]
              ]),
          /* directives */directives,
          /* selectionSet */t_selection_set(c, tpe_to_name(nfd[/* tpe */3]), f[/* selectionSet */4])
        ];
}

function t_inline_fragment(c, t, f) {
  var condition = Utils.opt_map((function (n) {
          var td = Curry._1(c[/* find_type */1], n);
          return td[0][/* name */1];
        }), f[/* condition */0]);
  var match = f[/* condition */0];
  var selections = t_selection_set(c, match !== undefined ? match : t, f[/* selectionSet */2]);
  return /* record */[
          /* condition */condition,
          /* directives */List.map((function (param) {
                  return t_directive(c, param);
                }), f[/* directives */1]),
          /* selectionSet */selections
        ];
}

function t_selection_set(c, t, o) {
  return List.fold_right((function (param, param$1) {
                var c$1 = c;
                var t$1 = t;
                var s = param;
                var acc = param$1;
                switch (s.tag | 0) {
                  case 0 : 
                      var f = s[0];
                      if (starts_with(f[/* name */1], "__")) {
                        return acc;
                      } else {
                        return /* :: */[
                                /* Field */Block.__(0, [t_field(c$1, t$1, f)]),
                                acc
                              ];
                      }
                  case 1 : 
                      return /* :: */[
                              /* FragmentSpread */Block.__(1, [t_fragment_spread(c$1, s[0])]),
                              acc
                            ];
                  case 2 : 
                      return /* :: */[
                              /* InlineFragment */Block.__(2, [t_inline_fragment(c$1, t$1, s[0])]),
                              acc
                            ];
                  
                }
              }), o, /* [] */0);
}

function t_operation(c, o) {
  var t = Curry._1(c[/* find_operation */0], o[/* tpe */0])[/* tpe */1];
  return /* record */[
          /* tpe */o[/* tpe */0],
          /* name */o[/* name */1],
          /* variables */o[/* variables */2],
          /* directives */List.map((function (param) {
                  return t_directive(c, param);
                }), o[/* directives */3]),
          /* selectionSet */t_selection_set(c, t, o[/* selectionSet */4])
        ];
}

function c$3(t, e) {
  var c_000 = function (o) {
    var match = Utils.find_opt((function (param) {
            return param[/* operation */0] === o;
          }), t[/* os */1][/* schema */0][/* operations */1]);
    if (match !== undefined) {
      return match;
    } else {
      throw [
            Transformation_error$1,
            "Failed to find operation"
          ];
    }
  };
  var c_001 = function (n) {
    try {
      return List.assoc(n, t[/* tr */2][/* types */0]);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        throw [
              Transformation_error$1,
              "Failed to fetch type: " + n
            ];
      } else {
        throw exn;
      }
    }
  };
  var c_002 = function (o, f) {
    try {
      return List.assoc(/* tuple */[
                  o,
                  f
                ], t[/* tr */2][/* fields */1]);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        throw [
              Transformation_error$1,
              "Failed to find field: " + (o + ("." + f))
            ];
      } else {
        throw exn;
      }
    }
  };
  var c_003 = function (d, f) {
    try {
      return List.assoc(/* tuple */[
                  d,
                  f
                ], t[/* tr */2][/* directive_arguments */4]);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        throw [
              Transformation_error$1,
              "Failed to find directive argument: " + (d + ("." + f))
            ];
      } else {
        throw exn;
      }
    }
  };
  var c_004 = function (o, f) {
    try {
      return List.assoc(/* tuple */[
                  o,
                  f
                ], t[/* tr */2][/* input_fields */2]);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        throw [
              Transformation_error$1,
              "Failed to find field: " + (o + ("." + f))
            ];
      } else {
        throw exn;
      }
    }
  };
  var c_005 = function (o, f, a) {
    try {
      return List.assoc(/* tuple */[
                  o,
                  f,
                  a
                ], t[/* tr */2][/* arguments */3]);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        throw [
              Transformation_error$1,
              "Failed to find argument: " + (o + ("." + (f + ("." + a))))
            ];
      } else {
        throw exn;
      }
    }
  };
  var c_006 = function (o, f) {
    try {
      return List.assoc(/* tuple */[
                  o,
                  f
                ], t[/* tr */2][/* new_fields */5]);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        throw [
              Transformation_error$1,
              "Failed to find field type: " + (o + ("." + f))
            ];
      } else {
        throw exn;
      }
    }
  };
  var c_007 = function (o, f) {
    var filtered = List.filter((function (param) {
              var match = param[0];
              if (match[0] === o) {
                return match[1] === f;
              } else {
                return false;
              }
            }))(t[/* tr */2][/* fixed_arguments */6]);
    return List.map((function (param) {
                  return param[1];
                }), filtered);
  };
  var c_008 = function (o) {
    var filtered = List.filter((function (param) {
              return param[0] === o;
            }))(t[/* tr */2][/* fixed_input_fields */7]);
    return List.map((function (param) {
                  return param[1];
                }), filtered);
  };
  var c$4 = /* record */[
    c_000,
    c_001,
    c_002,
    c_003,
    c_004,
    c_005,
    c_006,
    c_007,
    c_008
  ];
  return /* record */[
          /* operation */t_operation(c$4, e[/* operation */0]),
          /* fragments */List.map((function (param) {
                  var c$5 = c$4;
                  var f = param;
                  var td = Curry._1(c$5[/* find_type */1], f[/* condition */1]);
                  return /* record */[
                          /* name */f[/* name */0],
                          /* condition */td[0][/* name */1],
                          /* directives */List.map((function (param) {
                                  return t_directive(c$5, param);
                                }), f[/* directives */2]),
                          /* selectionSet */f[/* selectionSet */3]
                        ];
                }), e[/* fragments */1])
        ];
}

var executable = c$3;

exports.transform = transform;
exports.schema = schema;
exports.executable = executable;
/* No side effect */
