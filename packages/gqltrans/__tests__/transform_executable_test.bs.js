// Generated by BUCKLESCRIPT VERSION 4.0.7, PLEASE EDIT WITH CARE
'use strict';

var Jest = require("@glennsl/bs-jest/src/jest.js");
var Lexing = require("bs-platform/lib/js/lexing.js");
var Gql_ast = require("../src/gql_ast.bs.js");
var Gql_lexer = require("../src/gql_lexer.bs.js");
var Transform = require("../src/transform.bs.js");
var Gql_parser = require("../src/gql_parser.bs.js");
var Trans_lexer = require("../src/trans_lexer.bs.js");
var Trans_parser = require("../src/trans_parser.bs.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

var $$Error = Caml_exceptions.create("Transform_executable_test.Error");

function parse_schema(param) {
  return Gql_parser.$$document(Gql_lexer.read, param);
}

function parse_executable_string(s) {
  var match = Gql_ast.document_to_executable_document(parse_schema(Lexing.from_string(s)));
  if (match !== undefined) {
    return match;
  } else {
    throw $$Error;
  }
}

function parse_schema_string(s) {
  var match = Gql_ast.document_to_schema_document(parse_schema(Lexing.from_string(s)));
  if (match !== undefined) {
    return match;
  } else {
    throw $$Error;
  }
}

function parse_trans(param) {
  return Trans_parser.$$document(Trans_lexer.read, param);
}

function parse_trans_string(s) {
  return parse_trans(Lexing.from_string(s));
}

function testPrograms(n, schema, t, p1, p2) {
  return Jest.test(n, (function (param) {
                return Jest.Expect[/* toEqual */12](parse_executable_string(p2), Jest.Expect[/* expect */0](Transform.executable(Transform.transform(parse_schema_string(schema), parse_trans(Lexing.from_string(t))), parse_executable_string(p1))));
              }));
}

describe("Transform", (function () {
        describe("executable", (function () {
                testPrograms("field alias", "\n            type Query {\n              field: String\n            }\n            ", "\n            transform type Query {\n              f1: field\n            }\n            ", "\n            query {\n              f1\n            }\n            ", "\n            query {\n              f1: field\n            }\n            ");
                testPrograms("type alias", "\n            type T {\n              f2: String\n            }\n            type Query {\n              f1: T\n            }\n            ", "\n            transform type X: T\n            ", "\n            query {\n              f1 {\n                f2\n              }\n            }\n            ", "\n            query {\n              f1 {\n                f2\n              }\n            }\n            ");
                testPrograms("mutiple field alias", "\n            type Query {\n              field: String\n            }\n            ", "\n            transform type Query {\n              f1: field\n              f2: field\n            }\n            ", "\n            query {\n              f1\n              f2\n            }\n            ", "\n            query {\n              f1: field\n              f2: field\n            }\n            ");
                testPrograms("fix arg", "\n            type Query {\n              field(a1: String): String\n            }\n            ", "\n            transform type Query {\n              f1: field(a1 = \"foobar\")\n            }\n            ", "\n            query {\n              f1\n            }\n            ", "\n            query {\n              f1: field(a1: \"foobar\")\n            }\n            ");
                testPrograms("fix input", "\n\n            input I {\n              f1: String\n              f2: String\n            }\n            type Query {\n              field(a1: I): String\n            }\n            ", "\n            transform input I {\n              f2 = \"foobar\"\n            }\n            ", "\n            query {\n              field(a1: {f1: \"bar\"})\n            }\n            ", "\n            query {\n              field(a1: {f1: \"bar\" f2: \"foobar\"})\n            }\n            ");
                testPrograms("fix directive", "\n            input I {\n              f1: String\n              f2: String\n            }\n            directive @d(a1: I) on QUERY\n\n            type Query {\n              field(a1: String): String\n            }\n            ", "\n            transform input I {\n              f2 = \"foo\"\n            }\n            ", "\n            query @d(a1: {f1 : \"bar\"})\n            {\n              field @d(a1: {f1 : \"bar\"})\n            }\n            ", "\n            query @d(a1: {f1 : \"bar\", f2: \"foo\"}) \n            {\n              field @d(a1: {f1 : \"bar\", f2: \"foo\"}) \n            }\n            ");
                testPrograms("fix type argument", "\n            type A {\n              fa: String\n            }\n\n            type B {\n              fb: String\n            }\n            union U = A | B\n            type Query {\n              u: U\n            }\n            ", "\n            transform type AA: A\n            transform type BB: B\n            ", "\n            query\n            {\n              u {\n                ... on AA {\n                  fa\n                }\n                ... on BB {\n                  fb\n                }\n              }\n            }\n            ", "\n            query\n            {\n              u {\n                ... on A {\n                  fa\n                }\n                ... on B {\n                  fb\n                }\n              }\n            }\n            ");
                testPrograms("filter sytem fields", "\n            type Query {\n              field: String\n            }\n            ", "\n            transform type Query\n            ", "\n            query\n            {\n              field\n              __someInternalField\n            }\n            ", "\n            query\n            {\n              field\n            }\n            ");
                return testPrograms("fix type argument", "\n            type A {\n              fa: String\n            }\n\n            type B {\n              fb: String\n            }\n            union U = A | B\n            type Query {\n              u: U\n            }\n            ", "\n            transform type AA: A\n            transform type BB: B\n            ", "\n            fragment fa on AA {\n              fa\n            } \n            fragment fb on BB {\n              fb\n            }           \n            query\n            {\n              u {\n                ... fa\n                ... fb\n              }\n            }\n            ", "\n            fragment fa on A {\n              fa\n            } \n            fragment fb on B {\n              fb\n            }\n\n            query\n            {\n              u {\n                ...fa\n                ...fb\n              }\n            }\n            ");
              }));
        return /* () */0;
      }));

exports.$$Error = $$Error;
exports.parse_schema = parse_schema;
exports.parse_executable_string = parse_executable_string;
exports.parse_schema_string = parse_schema_string;
exports.parse_trans = parse_trans;
exports.parse_trans_string = parse_trans_string;
exports.testPrograms = testPrograms;
/*  Not a pure module */
