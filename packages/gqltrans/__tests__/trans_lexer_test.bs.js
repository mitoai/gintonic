// Generated by BUCKLESCRIPT VERSION 4.0.7, PLEASE EDIT WITH CARE
'use strict';

var Jest = require("@glennsl/bs-jest/src/jest.js");
var Block = require("bs-platform/lib/js/block.js");
var Lexing = require("bs-platform/lib/js/lexing.js");
var $$String = require("bs-platform/lib/js/string.js");
var Trans_lexer = require("../src/trans_lexer.bs.js");

function lex(buffer) {
  var t = Trans_lexer.read(buffer);
  if (typeof t === "number" && t === 20) {
    return /* :: */[
            t,
            /* [] */0
          ];
  } else {
    return /* :: */[
            t,
            lex(buffer)
          ];
  }
}

function testLexToEqual(program, result, param) {
  return Jest.Expect[/* toEqual */12](result, Jest.Expect[/* expect */0](lex(Lexing.from_string(program))));
}

function testName(program) {
  return "program: \"" + ($$String.escaped(program) + "\"");
}

function testProgram(program, result) {
  return Jest.test(testName(program), (function (param) {
                return testLexToEqual(program, result, param);
              }));
}

function testSingleToken(program, token) {
  return testProgram(program, /* :: */[
              token,
              /* :: */[
                /* EOF */20,
                /* [] */0
              ]
            ]);
}

function testEmptyProgram(program) {
  return testProgram(program, /* :: */[
              /* EOF */20,
              /* [] */0
            ]);
}

function testLexError(program, e) {
  return Jest.test(testName(program), (function (param) {
                return Jest.Expect[/* toThrowException */20](e, Jest.Expect[/* expect */0]((function (param) {
                                  return lex(Lexing.from_string(program));
                                })));
              }));
}

describe("Trans_lexer", (function () {
        testProgram(" ", /* :: */[
              /* EOF */20,
              /* [] */0
            ]);
        testProgram("\n", /* :: */[
              /* EOF */20,
              /* [] */0
            ]);
        testProgram("\t", /* :: */[
              /* EOF */20,
              /* [] */0
            ]);
        testSingleToken(":", /* COLON */22);
        testProgram(",", /* :: */[
              /* EOF */20,
              /* [] */0
            ]);
        testSingleToken("{", /* L_BRACKET */15);
        testSingleToken("}", /* R_BRACKET */9);
        testSingleToken("(", /* L_PAREN */14);
        testSingleToken(")", /* R_PAREN */8);
        testSingleToken("[", /* L_SQ_BRACKET */13);
        testSingleToken("]", /* R_SQ_BRACKET */7);
        testProgram("#asdasd", /* :: */[
              /* EOF */20,
              /* [] */0
            ]);
        testProgram("#asdasd", /* :: */[
              /* EOF */20,
              /* [] */0
            ]);
        testSingleToken("#asdasd\n      null", /* NULL */11);
        testSingleToken("true", /* TRUE */2);
        testSingleToken("false", /* FALSE */18);
        testSingleToken("null", /* NULL */11);
        testSingleToken("1234", /* INT */Block.__(2, ["1234"]));
        testSingleToken("-1234", /* INT */Block.__(2, ["-1234"]));
        testSingleToken("1234.0", /* FLOAT */Block.__(3, ["1234.0"]));
        testSingleToken("-1234.0", /* FLOAT */Block.__(3, ["-1234.0"]));
        testSingleToken("1234e12", /* FLOAT */Block.__(3, ["1234e12"]));
        testSingleToken("-1234e12", /* FLOAT */Block.__(3, ["-1234e12"]));
        testSingleToken("\"foobar\"", /* STRING */Block.__(0, ["foobar"]));
        testSingleToken("\"fo\\\"obar\"", /* STRING */Block.__(0, ["fo\\\"obar"]));
        testSingleToken("\"fo\\nobar\"", /* STRING */Block.__(0, ["fo\\nobar"]));
        testSingleToken("\"fo\\bobar\"", /* STRING */Block.__(0, ["fo\\bobar"]));
        testSingleToken("\"fo\\tobar\"", /* STRING */Block.__(0, ["fo\\tobar"]));
        testSingleToken("\"fo\\robar\"", /* STRING */Block.__(0, ["fo\\robar"]));
        testSingleToken("\"fo\\fobar\"", /* STRING */Block.__(0, ["fo\\fobar"]));
        testSingleToken("\"\"\"foobar\"baz\"\"\"", /* BLOCK_STRING */Block.__(4, ["foobar\"baz"]));
        testSingleToken("\"\"\"\n      foobar\n      baz\"\"\"", /* BLOCK_STRING */Block.__(4, ["\n      foobar\n      baz"]));
        testLexError("\"", [
              Trans_lexer.LexError,
              /* tuple */[
                "String not terminated",
                /* record */[
                  /* pos_fname */"",
                  /* pos_lnum */1,
                  /* pos_bol */0,
                  /* pos_cnum */1
                ]
              ]
            ]);
        testLexError("\"\\q", [
              Trans_lexer.LexError,
              /* tuple */[
                "Illegal character escape",
                /* record */[
                  /* pos_fname */"",
                  /* pos_lnum */1,
                  /* pos_bol */0,
                  /* pos_cnum */1
                ]
              ]
            ]);
        testSingleToken("foobar", /* NAME */Block.__(1, ["foobar"]));
        testSingleToken("truename", /* NAME */Block.__(1, ["truename"]));
        testSingleToken("foobar1234", /* NAME */Block.__(1, ["foobar1234"]));
        testSingleToken("a123", /* NAME */Block.__(1, ["a123"]));
        return testProgram("\n        Company: Entity {\n            test(lol:123, laz: \"123\"), foo, bar, baz,,\n        }\n        ", /* :: */[
                    /* NAME */Block.__(1, ["Company"]),
                    /* :: */[
                      /* COLON */22,
                      /* :: */[
                        /* NAME */Block.__(1, ["Entity"]),
                        /* :: */[
                          /* L_BRACKET */15,
                          /* :: */[
                            /* NAME */Block.__(1, ["test"]),
                            /* :: */[
                              /* L_PAREN */14,
                              /* :: */[
                                /* NAME */Block.__(1, ["lol"]),
                                /* :: */[
                                  /* COLON */22,
                                  /* :: */[
                                    /* INT */Block.__(2, ["123"]),
                                    /* :: */[
                                      /* NAME */Block.__(1, ["laz"]),
                                      /* :: */[
                                        /* COLON */22,
                                        /* :: */[
                                          /* STRING */Block.__(0, ["123"]),
                                          /* :: */[
                                            /* R_PAREN */8,
                                            /* :: */[
                                              /* NAME */Block.__(1, ["foo"]),
                                              /* :: */[
                                                /* NAME */Block.__(1, ["bar"]),
                                                /* :: */[
                                                  /* NAME */Block.__(1, ["baz"]),
                                                  /* :: */[
                                                    /* R_BRACKET */9,
                                                    /* :: */[
                                                      /* EOF */20,
                                                      /* [] */0
                                                    ]
                                                  ]
                                                ]
                                              ]
                                            ]
                                          ]
                                        ]
                                      ]
                                    ]
                                  ]
                                ]
                              ]
                            ]
                          ]
                        ]
                      ]
                    ]
                  ]);
      }));

exports.lex = lex;
exports.testLexToEqual = testLexToEqual;
exports.testName = testName;
exports.testProgram = testProgram;
exports.testSingleToken = testSingleToken;
exports.testEmptyProgram = testEmptyProgram;
exports.testLexError = testLexError;
/*  Not a pure module */
