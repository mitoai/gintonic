// Generated by BUCKLESCRIPT VERSION 4.0.7, PLEASE EDIT WITH CARE
'use strict';

var Jest = require("@glennsl/bs-jest/src/jest.js");
var Lexing = require("bs-platform/lib/js/lexing.js");
var Gql_ast = require("../src/gql_ast.bs.js");
var Js_utils = require("../src/js_utils.bs.js");
var Gql_lexer = require("../src/gql_lexer.bs.js");
var Transform = require("../src/transform.bs.js");
var Gql_parser = require("../src/gql_parser.bs.js");
var Trans_lexer = require("../src/trans_lexer.bs.js");
var Trans_parser = require("../src/trans_parser.bs.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

var $$Error = Caml_exceptions.create("Transform_schema_test.Error");

function parseS(param) {
  return Gql_parser.$$document(Gql_lexer.read, param);
}

function parseSS(s) {
  var match = Gql_ast.document_to_schema_document(parseS(Lexing.from_string(s)));
  if (match !== undefined) {
    return match;
  } else {
    throw $$Error;
  }
}

function parseT(param) {
  return Trans_parser.$$document(Trans_lexer.read, param);
}

function parseTS(s) {
  return parseT(Lexing.from_string(s));
}

function testPrograms(n, p1, t, p2) {
  return Jest.test(n, (function (param) {
                return Jest.Expect[/* toEqual */12](Js_utils.schema_document_to_js(parseSS(p2)), Jest.Expect[/* expect */0](Js_utils.schema_document_to_js(Transform.schema(Transform.transform(parseSS(p1), parseT(Lexing.from_string(t)))))));
              }));
}

describe("Transform", (function () {
        describe("schema", (function () {
                testPrograms("schema limit 1", "\n            type Q {\n              f: String\n            }\n            type M {\n              f: String\n            }\n            schema {\n              query: Q\n              mutation: M\n            }\n            ", "\n            transform schema {\n              query\n            }\n            ", "\n            type Q {\n              f: String\n            }\n            schema {\n              query: Q\n            }\n            ");
                return testPrograms("schema limit 2", "\n            type Query {\n              f: String\n            }\n            ", "\n            transform type Query\n            ", "\n            type Query {\n              f: String\n            }\n            schema {\n              query: Query\n            }\n            ");
              }));
        describe("type", (function () {
                testPrograms("alias field", "\n            type Q {\n              baz: String\n              foo: String\n            }\n            schema {\n              query: Q\n            }\n            ", "\n            transform type Q {\n              bar: foo\n            }\n            ", "\n            type Q {\n              bar: String\n            }\n            schema {\n              query: Q\n            }\n            ");
                testPrograms("alias type", "\n            type Q {\n              foo: String\n            }\n            schema {\n              query: Q\n            }\n            ", "\n            transform type X: Q\n            ", "\n            type X {\n              foo: String\n            }\n            schema {\n              query: X\n            }\n            ");
                testPrograms("remove field", "\n            type Q {\n              bar: String\n              foo: String\n            }\n            schema {\n              query: Q\n            }\n            ", "\n            transform type Q {\n              foo\n            }\n            ", "\n            type Q {\n              foo: String\n            }\n            schema {\n              query: Q\n            }\n            ");
                testPrograms("remove field and three-shake", "\n            type M {\n              bar: String\n            }\n            type Q {\n              foo: M\n              bar: String\n            }\n            schema {\n              query: Q\n            }\n            ", "\n            transform type Q {\n              bar\n            }\n            ", "\n            type Q {\n              bar: String\n            }\n            schema {\n              query: Q\n            }\n            ");
                testPrograms("remove field and three-shake rec-type", "\n            type M {\n              bar: M\n            }\n            type Q {\n              foo: M\n              bar: String\n            }\n            schema {\n              query: Q\n            }\n            ", "\n            transform type Q {\n              bar\n            }\n            ", "\n            type Q {\n              bar: String\n            }\n            schema {\n              query: Q\n            }\n            ");
                testPrograms("remove field and three-shake mut rec-type", "\n            type M {\n              bar: N\n            }\n            type N {\n              bar: M\n            }\n            type Q {\n              foo: M\n              bar: String\n            }\n            schema {\n              query: Q\n            }\n            ", "\n            transform type Q {\n              bar\n            }\n            ", "\n            type Q {\n              bar: String\n            }\n            schema {\n              query: Q\n            }\n            ");
                testPrograms("remove field and three-shake interface type", "\n            interface I {\n              bar: String\n            }\n            type M implements I {\n              bar: String\n            }\n            type Q {\n              foo: M\n              bar: I\n            }\n            schema {\n              query: Q\n            }\n            ", "\n            transform type Q {\n              bar\n            }\n            ", "\n            interface I {\n              bar: String\n            }\n            type M implements I {\n              bar: String\n            }\n\n            type Q {\n              bar: I\n            }\n            schema {\n              query: Q\n            }\n            ");
                testPrograms("remove field and three-shake + interface type", "\n            interface I {\n              bar: String\n            }\n            type M implements I {\n              bar: String\n            }\n            type Q {\n              foo: M\n              bar: String\n            }\n            schema {\n              query: Q\n            }\n            ", "\n            transform type Q {\n              bar\n            }\n            ", "\n            type Q {\n              bar: String\n            }\n            schema {\n              query: Q\n            }\n            ");
                testPrograms("remove arg", "\n            type Q {\n              foo(arg: String): String\n            }\n            schema {\n              query: Q\n            }\n            ", "\n            transform type Q {\n              foo(arg = \"\")\n            }\n            ", "\n            type Q {\n              foo: String\n            }\n            schema {\n              query: Q\n            }\n            ");
                testPrograms("remove one arg", "\n            type Q {\n              foo(arg: String arg2: Boolean arg3: Boolean): String\n            }\n            schema {\n              query: Q\n            }\n            ", "\n            transform type Q {\n              foo(arg = \"\")\n            }\n            ", "\n            type Q {\n              foo(arg2: Boolean arg3: Boolean): String\n            }\n            schema {\n              query: Q\n            }\n            ");
                return testPrograms("Update docs", "\n            \"olddoc1\"\n            type Q {\n              \"olddoc2\"\n              foo(\n                \"olddoc3\"\n                arg: String\n                \"olddoc4\"\n                arg2: String\n                ): String\n\n            }\n            schema {\n              query: Q\n            }\n            ", "\n            \"newdoc1\"\n            transform type Q {\n              \"newdoc2\"\n              foo(\n                \"newdoc3\"\n                arg\n              )\n            }\n            ", "\n            \"newdoc1\"\n            type Q {\n              \"newdoc2\"\n              foo(\n                \"newdoc3\"\n                arg: String\n                \"olddoc4\"\n                arg2: String\n                ): String\n            }\n            schema {\n              query: Q\n            }\n            ");
              }));
        describe("interface", (function () {
                testPrograms("alias field", "\n            interface Q {\n              baz: String\n              foo: String\n            }\n            type Query {\n              f: Q\n            }\n            ", "\n            transform interface Q {\n              bar: foo\n            }\n            ", "\n            interface Q {\n              bar: String\n            }\n            type Query {\n              f: Q\n            }\n            ");
                testPrograms("alias field", "\n            interface Q {\n              foo: String\n            }\n            type F implements Q {\n              foo: String\n            }\n            type Query {\n              f: F\n            }\n\n            ", "\n            transform interface X: Q \n            ", "\n            interface X {\n              foo: String\n            }\n            type F implements X {\n              foo: String\n            }\n\n            type Query {\n              f: F\n            }\n            ");
                testPrograms("alias field", "\n            interface Q {\n              foo: Q\n            }\n            type F implements Q {\n              foo: Q\n            }\n            type Query {\n              f: F\n            }\n\n            ", "\n            transform interface X: Q \n            ", "\n            interface X {\n              foo: X\n            }\n            type F implements X {\n              foo: X\n            }\n\n            type Query {\n              f: F\n            }\n            ");
                testPrograms("alias type", "\n            interface Q {\n              foo: String\n            }\n            type Query {\n              f: Q\n            }\n\n            ", "\n            transform interface X: Q\n            ", "\n            interface X {\n              foo: String\n            }\n            type Query {\n              f: X\n            }\n\n            ");
                testPrograms("remove field", "\n            interface Q {\n              bar: String\n              foo: String\n            }\n            type Query {\n              f: Q\n            }\n\n            ", "\n            transform interface Q {\n              foo\n            }\n            ", "\n            interface Q {\n              foo: String\n            }\n            type Query {\n              f: Q\n            }\n            ");
                testPrograms("remove arg", "\n            interface Q {\n              foo(arg: String): String\n            }\n            type Query {\n              f: Q\n            }\n            ", "\n            transform interface Q {\n              foo(arg = \"\")\n            }\n            ", "\n            interface Q {\n              foo: String\n            }\n            type Query {\n              f: Q\n            }\n            ");
                testPrograms("remove one arg", "\n            interface Q {\n              foo(arg: String arg2: Boolean arg3: Boolean): String\n            }\n            type Query {\n              f: Q\n            }\n            ", "\n            transform interface Q {\n              foo(arg = \"\")\n            }\n            ", "\n            interface Q {\n              foo(arg2: Boolean arg3: Boolean): String\n            }\n            type Query {\n              f: Q\n            }\n            ");
                return testPrograms("Update docs", "\n            \"olddoc1\"\n            interface Q {\n              \"olddoc2\"\n              foo(\n                \"olddoc3\"\n                arg: String\n                \"olddoc4\"\n                arg2: String\n                ): String\n\n            }\n            type Query {\n              f: Q\n            }\n            ", "\n            \"newdoc1\"\n            transform interface Q {\n              \"newdoc2\"\n              foo(\n                \"newdoc3\"\n                arg\n              )\n            }\n            ", "\n            \"newdoc1\"\n            interface Q {\n              \"newdoc2\"\n              foo(\n                \"newdoc3\"\n                arg: String\n                \"olddoc4\"\n                arg2: String\n                ): String\n            }\n            type Query {\n              f: Q\n            }\n            ");
              }));
        describe("scalar", (function () {
                testPrograms("noop", "\n            scalar T\n            type Query {\n              f: T\n            }\n            ", "\n            transform scalar T\n            ", "\n            scalar T\n            type Query {\n              f: T\n            }\n            ");
                testPrograms("update docs", "\n            scalar T\n            type Query {\n              f: T\n            }\n            ", "\n            \"docs\"\n            transform scalar T\n            ", "\n            \"docs\"\n            scalar T\n            type Query {\n              f: T\n            }\n            ");
                testPrograms("update docs", "\n            \"olddocs\"\n            scalar T\n            type Query {\n              f: T\n            }\n            ", "\n            \"docs\"\n            transform scalar T\n            ", "\n            \"docs\"\n            scalar T\n            type Query {\n              f: T\n            }\n            ");
                return testPrograms("alias type", "\n            scalar T\n            type Query {\n              f: T\n            }\n\n            ", "\n            transform scalar X: T\n            ", "\n            scalar X\n            type Query {\n              f: X\n            }\n            ");
              }));
        describe("union", (function () {
                testPrograms("noop", "\n            type F {\n              f: String\n            }\n            union T = F\n            type Query {\n              f: T\n            }\n            ", "\n            transform union T\n            ", "\n            type F {\n              f: String\n            }\n            union T = F\n            type Query {\n              f: T\n            }\n            ");
                testPrograms("update docs", "\n            type F {\n              f: String\n            }\n            union T = F\n            type Query {\n              f: T\n            }\n            ", "\n            \"docs\"\n            transform union T\n            ", "\n            type F {\n              f: String\n            }\n            \"docs\"\n            union T = F\n            type Query {\n              f: T\n            }\n            ");
                testPrograms("update docs", "\n            type F {\n              f: String\n            }\n            \"olddocs\"\n            union T = F\n            type Query {\n              f: T\n            }\n            ", "\n            \"docs\"\n            transform union T\n            ", "\n            type F {\n              f: String\n            }\n            \"docs\"\n            union T = F\n            type Query {\n              f: T\n            }\n            ");
                testPrograms("alias type", "\n            type F {\n              f: String\n            }\n            \"olddocs\"\n            union T = F\n            type Query {\n              f: T\n            }\n            ", "\n            \"docs\"\n            transform union X: T\n            ", "\n            type F {\n              f: String\n            }\n            \"docs\"\n            union X = F\n            type Query {\n              f: X\n            }\n            ");
                return testPrograms("alias member type", "\n            type F {\n              f: String\n            }\n            union T = F\n            type Query {\n              f: T\n            }\n            ", "\n            transform type X: F\n            ", "\n            type X {\n              f: String\n            }\n            union T = X\n            type Query {\n              f: T\n            }\n            ");
              }));
        describe("enum", (function () {
                testPrograms("noop", "\n            enum T {\n              VAR\n            }\n            type Query {\n              f: T\n            }\n            ", "\n            transform enum T\n            ", "\n            enum T {\n              VAR\n            }\n            type Query {\n              f: T\n            }\n            ");
                testPrograms("update docs", "\n            enum T {\n              VAR\n            }\n            type Query {\n              f: T\n            }\n            ", "\n            \"docs\"\n            transform enum T\n            ", "\n            \"docs\"\n            enum T {\n              VAR\n            }\n            type Query {\n              f: T\n            }\n            ");
                testPrograms("update docs 2", "\n            \"olddocs\"\n            enum T {\n              VAR\n            }\n            type Query {\n              f: T\n            }\n            ", "\n            \"docs\"\n            transform enum T\n            ", "\n            \"docs\"\n            enum T {\n              VAR\n            }\n            type Query {\n              f: T\n            }\n            ");
                testPrograms("update docs 3", "\n            \"olddocs\"\n            enum T {\n              VALUE VALUE2\n            }\n            type Query {\n              f: T\n            }\n            ", "\n            \"docs\"\n            transform enum T {\n              \"docs2\"\n              VALUE\n            }\n            ", "\n            \"docs\"\n            enum T {\n              \"docs2\"\n              VALUE VALUE2\n            }\n            type Query {\n              f: T\n            }\n            ");
                return testPrograms("alias type", "\n            enum T {\n              VAR\n            }\n            type Query {\n              f: T\n            }\n            ", "\n            transform enum X: T\n            ", "\n            enum X {\n              VAR\n            }\n            type Query {\n              f: X\n            }\n            ");
              }));
        describe("input object", (function () {
                testPrograms("noop", "\n            input T {\n              f: String\n            }\n            type Q {\n              f(a: T): String\n            }\n\n            schema { query: Q }\n            ", "\n            transform input T\n            ", "\n            input T {\n              f: String\n            }\n            type Q {\n              f(a: T): String\n            }\n            schema { query: Q }\n            ");
                testPrograms("directive", "\n            directive @foobar(arg: T) on SCHEMA\n\n            input T {\n              f: String\n            }\n            type Q {\n              f: String\n            }\n            schema { query: Q }\n            ", "\n            transform input X: T\n            ", "\n            directive @foobar(arg: X) on SCHEMA\n\n            input X {\n              f: String\n            }\n            type Q {\n              f: String\n            }\n            schema \n            { query: Q }\n            ");
                testPrograms("fix field", "\n            input T {\n              t: String\n              f: String\n            }\n            type Query {\n              f(a: T): String\n            }\n            ", "\n            transform input T {\n              f = \"foobar\"\n            }\n            ", "\n            input T {\n              t: String\n            }\n            type Query {\n              f(a: T): String\n            }\n\n\n            ");
                testPrograms("fix field w. default value", "\n            input T {\n              t: String\n              f: String\n            }\n            type Q {\n              foo(i: T = {f : \"f\" t : \"t\"}): String\n            }\n            schema { query: Q }\n            ", "\n            transform input T {\n              f = \"foobar\"\n            }\n            ", "\n            input T {\n              t: String\n            }\n            type Q {\n              foo(i: T = {t : \"t\"}): String\n            }\n\n            schema { query: Q }\n            ");
                testPrograms("type alias", "\n            input T {\n              f: T\n            }\n            type Query {\n              f(a: T): String\n            }\n            ", "\n            transform input X: T\n            ", "\n            input X {\n              f: X\n            }\n            type Query {\n              f(a: X): String\n            }\n            ");
                return testPrograms("update directive", "\n            directive @foo (a: T = {f : \"f\" t : \"t\"}) on QUERY\n\n            input T {\n              f: String\n              t: String\n            }\n\n            type Query @foo(a: {f : \"f\" t : \"t\"}) {\n              f: String\n            }\n            ", "\n            transform input T {\n              f = \"foo\"\n            }\n            ", "\n            directive @foo (a: T = {t : \"t\"}) on QUERY\n            input T {\n              t: String\n            }\n            type Query @foo(a: {t : \"t\"}) {\n              f: String\n            }\n            ");
              }));
        return /* () */0;
      }));

exports.$$Error = $$Error;
exports.parseS = parseS;
exports.parseSS = parseSS;
exports.parseT = parseT;
exports.parseTS = parseTS;
exports.testPrograms = testPrograms;
/*  Not a pure module */
